#Объяснение

1. Анализируем поведение программы
bonus0@RainFall:~$ ./bonus0
 -
a
 -
a
a a

bonus0@RainFall:~$ ./bonus0
 -
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 -
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa��� aaaaaaaaaaaaaaaaaaaa���
Segmentation fault (core dumped)

Программа запрашивает на stditn ввод два раза, затем выводит две введенные строки через пробел.
Как видно, при введение большого количества символов возможна перезапись памяти и segfault.


2. ltrace
bonus0@RainFall:~$ ltrace ./bonus0
__libc_start_main(0x80485a4, 1, 0xbffff6f4, 0x80485d0, 0x8048640 <unfinished ...>
puts(" - " -
)                                                     = 4
read(0, A
"A\n", 4096)                                            = 2
strchr("A\n", '\n')                                             = "\n"
strncpy(0xbffff5d8, "A", 20)                                    = 0xbffff5d8
puts(" - " -
)                                                     = 4
read(0, B
"B\n", 4096)                                            = 2
strchr("B\n", '\n')                                             = "\n"
strncpy(0xbffff5ec, "B", 20)                                    = 0xbffff5ec
strcpy(0xbffff626, "A")                                         = 0xbffff626
strcat("A ", "B")                                               = "A B"
puts("A B"A B
)                                                     = 4
+++ exited (status 0) +++

Видим небезопасную функцию strcpy.

3. GDB

(gdb) disas main
   0x080485a4 <+0>:	    push   %ebp                 // пролог
   0x080485a5 <+1>:	    mov    %esp,%ebp
   0x080485a7 <+3>:	    and    $0xfffffff0,%esp     // устанавливаем вершину стека
   0x080485aa <+6>:	    sub    $0x40,%esp           // выделяем 64 байта на стеке
   0x080485ad <+9>:	    lea    0x16(%esp),%eax      // адрес из ESP со сдвигом 22 байта записываем в регистр EAX
   0x080485b1 <+13>:	mov    %eax,(%esp)          // значение из EAX кладем на вершину стека (аргумент)
   0x080485b4 <+16>:	call   0x804851e <pp>       // вызываем функцию pp с аргументом-буфером
   0x080485b9 <+21>:	lea    0x16(%esp),%eax      // кладем адрес буфера в EAX
   0x080485bd <+25>:	mov    %eax,(%esp)          // кладем адрес буфера на стек (аргумент)
   0x080485c0 <+28>:	call   0x80483b0 <puts@plt> // вызываем puts с аргументом-буфером
   0x080485c5 <+33>:	mov    $0x0,%eax            // кладем 0 на стек, с ним покинем main
   0x080485ca <+38>:	leave
   0x080485cb <+39>:	ret


(gdb) disas pp

   0x0804851e <+0>:	    push   %ebp                 // пролог
   0x0804851f <+1>:	    mov    %esp,%ebp
   0x08048521 <+3>:	    push   %edi                 // кладем значение EDI в стек
   0x08048522 <+4>:	    push   %ebx                 // кладем значение EBX в стек
   0x08048523 <+5>:	    sub    $0x50,%esp           // выделяем 80 байт на стеке
   0x08048526 <+8>:	    movl   $0x80486a0,0x4(%esp) // кладем " - " на стек (2 аргумент)
   0x0804852e <+16>:	lea    -0x30(%ebp),%eax     // кладем адрес буфера в 20 байт в EAX
   0x08048531 <+19>:	mov    %eax,(%esp)          // кладем адрес буфера на стек (1 аргумент)
   0x08048534 <+22>:	call   0x80484b4 <p>        // вызываем функцию p с 2мя аргументами
   0x08048539 <+27>:	movl   $0x80486a0,0x4(%esp) // кладем " - " на стек (2 аргумент)
   0x08048541 <+35>:	lea    -0x1c(%ebp),%eax     // кладем адрес буфера в 28 байт в регист EAX
   0x08048544 <+38>:	mov    %eax,(%esp)          // кладем буфер в стек (1 аргумент)
   0x08048547 <+41>:	call   0x80484b4 <p>        // вызываем функцию p с 2мя аргументами
   0x0804854c <+46>:	lea    -0x30(%ebp),%eax     // адрес первого буфера (20 байт) кладем в EAX
   0x0804854f <+49>:	mov    %eax,0x4(%esp)       // адрес первого буфера кладем на стек (2 аргумент)
   0x08048553 <+53>:	mov    0x8(%ebp),%eax       // адрес аргумента функции pp - буфер 42 байта кладем в EAX
   0x08048556 <+56>:	mov    %eax,(%esp)          // кладем адрес аргумента функции pp на стек (1 пргумент)
   0x08048559 <+59>:	call   0x80483a0 <strcpy@plt> // копируем значения из 1го буфера функции pp в буфер функции main
   0x0804855e <+64>:	mov    $0x80486a4,%ebx      // кладем адрес строки " " в регист EBX
   0x08048563 <+69>:	mov    0x8(%ebp),%eax       // адрес аргумента функции pp - буфер 42 байта кладем в EAX
   0x08048566 <+72>:	movl   $0xffffffff,-0x3c(%ebp) // кладем 0xffffffff перед первым буфером функции pp. 0 и -1
   0x0804856d <+79>:	mov    %eax,%edx            // адрес буфера из функции main кладем в EDX
   0x0804856f <+81>:	mov    $0x0,%eax            // кладем 0 в EAX
   0x08048574 <+86>:	mov    -0x3c(%ebp),%ecx     // адрес первого буфера со сдвигом -12 кладем в EAX
   0x08048577 <+89>:	mov    %edx,%edi            // адрес буфера из функции main кладем в EDI
   0x08048579 <+91>:	repnz scas %es:(%edi),%al   // вычисляем длину буфера из функции main
   0x0804857b <+93>:	mov    %ecx,%eax            // адрес первого буфера кладем в EAX
   0x0804857d <+95>:	not    %eax                 // получаем индекс '\0' буфера из main
   0x0804857f <+97>:	sub    $0x1,%eax            // вычитаем 1 из индекса '\0' и получаем main
   0x08048582 <+100>:	add    0x8(%ebp),%eax       // адрес буфера из main кладем в EAX
   0x08048585 <+103>:	movzwl (%ebx),%edx          // кладем ' ' в EDX
   0x08048588 <+106>:	mov    %dx,(%eax)           // заменяем '\0' в буфере из main на ' '
   0x0804858b <+109>:	lea    -0x1c(%ebp),%eax     // кладем адрес второго буфера функции pp (28 байт) в регистр EAX
   0x0804858e <+112>:	mov    %eax,0x4(%esp)       // кладем адрес второго буфера функции pp (28 байт) на стек (2 аргумент)
   0x08048592 <+116>:	mov    0x8(%ebp),%eax       // кладем адрес буфера из main в EAX
   0x08048595 <+119>:	mov    %eax,(%esp)          // кладем адрес буфера из main на уершину стека (1 аргумент)
   0x08048598 <+122>:	call   0x8048390 <strcat@plt> // вызываем strcat с 2мя аргументами
   0x0804859d <+127>:	add    $0x50,%esp           // в ESP кладем адрес EBP до вызова функции pp
   0x080485a0 <+130>:	pop    %ebx
   0x080485a1 <+131>:	pop    %edi
   0x080485a2 <+132>:	pop    %ebp
   0x080485a3 <+133>:	ret


(gdb) disas p

   0x080484b4 <+0>:	    push   %ebp                 // пролог
   0x080484b5 <+1>:	    mov    %esp,%ebp
   0x080484b7 <+3>: 	sub    $0x1018,%esp         // выделяем 4120 байт на стеке
   0x080484bd <+9>:	    mov    0xc(%ebp),%eax       // адрес 2 аргумента функции pp - " - " кладем в EAX
   0x080484c0 <+12>:	mov    %eax,(%esp)          // кладем " - " на стек (аргумент)
   0x080484c3 <+15>:	call   0x80483b0 <puts@plt> // вызываем puts с аргументом " - "
   0x080484c8 <+20>:	movl   $0x1000,0x8(%esp)    // кладем 4096 в стек (3 аргумент)
   0x080484d0 <+28>:	lea    -0x1008(%ebp),%eax   // кладем адрес буфера функции p в EAX
   0x080484d6 <+34>:	mov    %eax,0x4(%esp)       // адрес буфера функции p в стек (2 аргумент)
   0x080484da <+38>:	movl   $0x0,(%esp)          // кладем 0 на вершину стека (1 аргумент)
   0x080484e1 <+45>:	call   0x8048380 <read@plt> // вызываем read с аргументами
   0x080484e6 <+50>:	movl   $0xa,0x4(%esp)       // кладем 10['\n'] на стек (2 аргумент)
   0x080484ee <+58>:	lea    -0x1008(%ebp),%eax   // кладем адрес буфера функции p в регистр EAX
   0x080484f4 <+64>:	mov    %eax,(%esp)          // кладем адрес буфера функции p на вершину стека (1 аргумент)
   0x080484f7 <+67>:	call   0x80483d0 <strchr@plt>  // вызываем strchr с аргументами
   0x080484fc <+72>:	movb   $0x0,(%eax)          // кладем - по адресу '\n' в буфере функции p 0.
   0x080484ff <+75>:	lea    -0x1008(%ebp),%eax   // кладем адрес буфера функции p в EAX
   0x08048505 <+81>:	movl   $0x14,0x8(%esp)      // кладем 20 на стек (3 аргумент)
   0x0804850d <+89>:	mov    %eax,0x4(%esp)       // кладем адрес буфера функции p на стек (2 аргумент)
   0x08048511 <+93>:	mov    0x8(%ebp),%eax       // адрес буфера функции pp кладем в EAX
   0x08048514 <+96>:	mov    %eax,(%esp)          // адрес буфера функции pp кладем на стек (1 аргумент)
   0x08048517 <+99>:	call   0x80483f0 <strncpy@plt>  // вызываем strncpy с аргументами
   0x0804851c <+104>:	leave
   0x0804851d <+105>:	ret
