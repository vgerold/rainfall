# Решение




#Объяснение

1. Анализируем поведение программы
bonus1@RainFall:~$ ./bonus1 
Segmentation fault (core dumped)
bonus1@RainFall:~$ ./bonus1 a
bonus1@RainFall:~$ ./bonus1 a a
bonus1@RainFall:~$ ./bonus1 a a a
bonus1@RainFall:~$ ./bonus1 aaaa
bonus1@RainFall:~$ ./bonus1 aaaa aaaa
bonus1@RainFall:~$ ./bonus1 aaaa aaaa aaaa
bonus1@RainFall:~$ ./bonus1 aaaa aaaa aaaa aaaa

Программа сегфолтится без аргументов.


2. Вызовы функций:
bonus1@RainFall:~$ objdump -d ./bonus1 | grep call
 8048438:       e8 23 ff ff ff          call   8048360 <atoi@plt>
 8048473:       e8 a8 fe ff ff          call   8048320 <memcpy@plt>
 8048499:       e8 b2 fe ff ff          call   8048350 <execl@plt>
 
3. GDB

(gdb) disas main
Dump of assembler code for function main:
   0x08048424 <+0>:     push   %ebp			// сохранение регистра EBP в стек
   0x08048425 <+1>:     mov    %esp,%ebp		// запись указателя начала стека в регистр EBP
=> 0x08048427 <+3>:     and    $0xfffffff0,%esp		// вершина стека
   0x0804842a <+6>:     sub    $0x40,%esp		// выделение 64 байт памяти на стеке
   
   
   
   0x0804842d <+9>:     mov    0xc(%ebp),%eax		// копия 4х байт EBP со смещением +12 в регистр EAX
   0x08048430 <+12>:    add    $0x4,%eax		// добавление 4 в младший байт EAX
   0x08048433 <+15>:    mov    (%eax),%eax		// запись содержимого по адресу EAX в регистр EAX
   0x08048435 <+17>:    mov    %eax,(%esp)		// кладем содержимое регистра EAX (аргумент, переданный как argv[1]) на стек
   0x08048438 <+20>:    call   0x8048360 <atoi@plt>	// вызов atoi с аргументом указателя, переданного как argv[1]
   0x0804843d <+25>:    mov    %eax,0x3c(%esp)		// кладем содержимое регистра EAX (результат atoi) на стек со смещением 60 байт

   
   0x08048441 <+29>:    cmpl   $0x9,0x3c(%esp)		// сравниваем как long 9 и полученное значение из atoi(argv[1])
   0x08048446 <+34>:    jle    0x804844f <main+43>	// переход, если 9 <= argv[1]
   0x08048448 <+36>:    mov    $0x1,%eax		// иначе, ret = 1
   0x0804844d <+41>:    jmp    0x80484a3 <main+127>	// переход на смещение +127
   
   
   0x0804844f <+43>:    mov    0x3c(%esp),%eax		// ESP+60 (результат atoi(argv[1])) записать в EAX (буфер)
   0x08048453 <+47>:    lea    0x0(,%eax,4),%ecx	// ecx = eax*4+0
   0x0804845a <+54>:    mov    0xc(%ebp),%eax		// eax = ebp+12
   0x0804845d <+57>:    add    $0x8,%eax		// eax + 8
   0x08048460 <+60>:    mov    (%eax),%eax		// eax = *eax
   0x08048462 <+62>:    mov    %eax,%edx		// edx = eax
   0x08048464 <+64>:    lea    0x14(%esp),%eax		// eax = esp+20
   
   0x08048468 <+68>:    mov    %ecx,0x8(%esp)		// arg_2  = ecx
   0x0804846c <+72>:    mov    %edx,0x4(%esp)		// argv_1 = edx
   0x08048470 <+76>:    mov    %eax,(%esp)		// argv_0 = eax
   0x08048473 <+79>:    call   0x8048320 <memcpy@plt>	// memcpy(eax, edx, ecx)

   
   0x08048478 <+84>:    cmpl   $0x574f4c46,0x3c(%esp)	// сравнить число 0x574f4c46 (1 464 814 662) с результатом atoi(argv[1]) - EAX+60
   0x08048480 <+92>:    jne    0x804849e <main+122>	// переход на +122 смещение

   
   0x08048482 <+94>:    movl   $0x0,0x8(%esp)		// arg_2 = 0
   0x0804848a <+102>:   movl   $0x8048580,0x4(%esp)	// arg_1 = "sh" 
   0x08048492 <+110>:   movl   $0x8048583,(%esp)	// arg_0 = "/bin/sh" на стек
   0x08048499 <+117>:   call   0x8048350 <execl@plt>	// вызов execl("bin/sh", "sh", 0)
   0x0804849e <+122>:   mov    $0x0,%eax		// ret = 0

   
   0x080484a3 <+127>:   leave  				// return (ret)
   0x080484a4 <+128>:   ret    
   
Если подается argv 0 или argv >9, то программа завершается без ошибки. 
Если argv = 9, или argv < 0, то segfault.
   
Есть memcpy()


gcc -fno-stack-protector -z exestack -m32 -g test.c -o test


4. Взлом

Задача: с помощью переполнения буфера и перезаписи стека функции main подменить указатель возврата на адрес шеллкода.

1. Шеллкод мы расположим в буфере функции p, примерно, в середине. Перед ним запишем символы \x90, которые обозначают
    операцию NOP - ничего не исполнять и перейти к следующей инструкции.
2. Адрес возврата перезапишем на адрес буфера функции p+200. (0xbfffe580 + 200 = 0xbfffe648)
3. Куда положить адрес возврата?
   Посчитаем количество байт между началом буфера функции main и ее адресом возврата.
   (gdb) p/d $ebp + 4 - $esp - 0x16
   $7 = 54

   Соответственно, нам необходимо 54 байта какой-то нагрузки.

   Путем нехитрых рассчетов мы определяем, что адрес на шеллкод должен начинаться с 15 символа второго ввода.
   20(первый ввод) + 19(второй ввод) + 19(второй ввод).


Итоговый эксплойт:

